classdef nb_writeHelp
% Description:
%
% A class for writing the help for the estimator packages and model 
% classes of the NB Toolbox.
%
% Constructor:
%
%   obj = nb_writeHelp(name,option,typeName,dataType)
% 
%   Input:
%
%   - name     : The name of the class or package to document.
%
%   - option   : Either the name of the option or 'all'.
% 
%   - typeName : Indicate if it is a class ('class') or package 
%                ('package').
%
%   - dataType : Either 'timeSeries', 'crossSectional' or 'both'. 
% 
%   Output:
% 
%   - obj    : An object of class nb_writeHelp.
% 
%   Examples:
% 
% Written by Kenneth Sæterhagen Paulsen
    
% Copyright (c) 2023, Kenneth Sæterhagen Paulsen

    properties
        
        % Either 'timeSeries', 'crossSectional' or 'both'.
        dataType    = 'timeSeries';
        
        % Max number of chars in the printed doc.
        max         = 40;
        
        % Name of the package or class.
        nameOfPOrC  = '';
        
        % The option to get the help on, or 'all'.
        option      = 'all';
        
        % Indicate if it is a class or package
        typeName    = 'class';
        
    end
    
    properties (SetAccess=protected)
        
        % A struct that stores the help text of all the options.
        helpStruct  = struct();
        
        % A cellstr with the names of the options that the 
        options     = {};
        
    end
    
    methods
        
        function obj = nb_writeHelp(name,option,typeName,dataType)
            
            if nargin == 0
                return
            end
            
            if ~(ischar(option) || iscellstr(option)) %#ok<ISCLSTR>
                error('The option input must be a char.')
            end
            obj.dataType   = dataType;
            obj.nameOfPOrC = name;
            obj.option     = option;
            ind            = strfind(name,'.');
            if ~isempty(ind)
                templateFunc = str2func([name(1:ind-1) '.template']); 
                obj.options  = fieldnames(templateFunc(name(ind+1:end)));
            else
                templateFunc = str2func([name '.template']); 
                obj.options  = fieldnames(templateFunc());
            end
            
            obj.typeName = typeName;
            
        end
        
        function obj = set(obj,varargin)
        % Syntax:
        % 
        % obj = set(obj,varargin)
        % 
        % Description:
        % 
        % Sets the properties of an object of class nb_writeHelp. Give the 
        % property name as a string. The input that follows should be the 
        % value you want to assign to the property. 
        %
        % Multiple properties can be set with one method call.
        % 
        % Input:
        % 
        % - obj      : An object of class nb_writeHelp.
        % 
        % - varargin : Every odd input must be a string with the name of 
        %              the property wanted to be set. Every even input must
        %              be the value you want to set the given property to.
        % 
        % Output:
        % 
        % - obj      : The same object of class nb_writeHelp with the 
        %              given properties reset
        % 
        % Examples:
        % 
        % obj.set('propertyName',propertyValue,...);
        % 
        % Written by Kenneth Sæterhagen Paulsen

            if size(varargin,1) && iscell(varargin{1})
                varargin = varargin{1};
            end

            for jj = 1:2:size(varargin,2)
                if ischar(varargin{jj})
                    propertyName  = lower(varargin{jj});
                    propertyValue = varargin{jj + 1};
                    switch propertyName
                        case 'datatype'
                            obj.dataType = propertyValue;
                        case 'max'
                            if isempty(propertyValue)
                                obj.max = 40;
                            else
                                obj.max = propertyValue;
                            end
                        case {'name','nameofporc'}
                            obj.nameOfPOrC = propertyValue;
                        case 'option'
                            obj.option = propertyValue;
                        case 'typename'
                            obj.typeName = propertyValue;    
                        otherwise
                            error([mfilename ':: Bad property name; ' propertyName])
                    end
                end
            end

        end
        
        function helpText = help(obj)
        % Syntax:
        %
        % helpText = help(obj)
        %
        % Description:
        %
        % Get the help given the property values of the object. 
        % 
        % Input:
        % 
        % - obj : An object of class nb_writeHelp.
        % 
        % Output:
        % 
        % - helpText : A char with the help on the package or class.
        %
        % Written by Kenneth Sæterhagen Paulsen    
           
            if strcmpi(obj.option,'all')
                
                for ii = 1:length(obj.options)
                    helpFuncH = str2func(lower(obj.options{ii}));
                    try
                        obj = helpFuncH(obj);
                    catch
                        obj = notDocumented(obj,obj.options{ii});
                    end
                end
                
                helpText    = '';
                helpOptions = '';
                obj.options = sort(obj.options);
                for ii = 1:length(obj.options)
                    helpTemp    = nb_wrapped(obj.helpStruct.(lower(obj.options{ii})),obj.max);
                    nLines      = size(helpTemp,1);
                    extra       = repmat({''},nLines,1); 
                    helpText    = char(helpText,helpTemp{:},'');
                    helpOptions = char(helpOptions,['- ' obj.options{ii}],extra{:});
                end
                colon    = ' : ';
                colon    = colon(ones(1,size(helpText,1)),:);
                helpText = [helpOptions,colon,helpText];
                
            else
                
                if ~any(strcmpi(obj.option,obj.options))
                    helpText = ['Valid inputs are either an option for the ' obj.nameOfPOrC ' ' obj.typeName ' or ''all''.'];
                    return
                end
                helpFuncH = str2func(lower(obj.option));
                try
                    obj = helpFuncH(obj);
                catch
                    obj = notDocumented(obj,obj.option);
                end
                helpTemp = nb_wrapped(obj.helpStruct.(lower(obj.option)),obj.max);
                nLines   = size(helpTemp,1);
                extra    = repmat({''},nLines-1,1);  
                helpText = char(['- ' obj.option ' : '],extra{:});
                helpText = [helpText,char(helpTemp)];
                
            end 
            
        end
        
    end
    
    methods (Access=protected)
        
        function obj = algorithm(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_arima') || strcmpi(obj.nameOfPOrC,'nb_model_selection_group') || strcmpi(obj.nameOfPOrC,'nb_arimaEstimator')
                obj.helpStruct.algorithm = ...
                    ['Sets the method for ARIMA estimation, can be ''hr'' or ''ml'', ',...
                     'for Hannan-Rissan and Maximum likelihood respectivly.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_midas') || strcmpi(obj.nameOfPOrC,'nb_midasEstimator')
                obj.helpStruct.algorithm = ...
                    ['Sets the algorithm used to estimate the MIDAS model, can be ''unrestricted'', ''beta'', ',...
                     '''legendre'', ''almon'' for unrestricted MIDAS, beta lag MIDAS (estimated using profiling)',...
                     ', legendre MIDAS and almon lag MIDAS respectively.'];
            else
                obj = notDocumented(obj,'algorithm'); 
            end
            
        end
        
        function obj = allperiods(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast') || ...
                    strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.enddate = ...
                    'Set to true to construct recursive scores/weights/combined forecast/aggregated forecast.';
            else
                obj.helpStruct.allperiods = ...
                    ['Give 1 (true) if you want to construct (density) forecast for all recursive forecast (which may ',...
                     'have been produced by the models stored in this object). Default is 0 (false), i.e. only to ',...
                     'produce forecast for the last period.'];
            end
            
        end
        
        function obj = alpha(obj)
            
            obj.helpStruct.alpha = ...
                ['Sets the significance level used by the ADF test for unit root. Only used when ',...
                 'integration option is set to empty. Default is 0.05. Must be between 0 and 1.'];

        end
        
        function obj = ar(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_arima') || strcmpi(obj.nameOfPOrC,'nb_arimaEstimator')
                obj.helpStruct.ar = ...
                    ['Lets you manually set the number of AR terms of the arima model. Set to nan if you want ',...
                     'the model to select the value for you.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_midas') || strcmpi(obj.nameOfPOrC,'nb_midasEstimator')
                obj.helpStruct.ar = ...
                    ['Indicate if you want to estimate the AR specification of the MIDAS model. If the ',...
                     'algorithm is not set to ''unrestricted'', a correction will be made on the coefficients of ',...
                     'the other regressors to prevent seasonal pattern in the estimates. true or false.'];
            else
                obj = notDocumented(obj,'ar'); 
            end
            
        end
        
        function obj = bins(obj)
            obj.helpStruct.bins = ...
                'See the corresponding input to the nb_model_generic.forecast method.';
        end
        
        function obj = blockdecompose(obj)
            obj.helpStruct.blockdecompose = ...
                ['Set it to true to remove all equations that does not contain any information for the ',...
                 'solution of the decision rules, i.e seperate out the epilogue of the model. Default ',...
                 'is false. This may increase the speed of solving and estimation of the model. The ',...
                 'epilogue will be solved for in the end. Mainly for models solved under optimal policy.'];
        end
        
        function obj = blocktol(obj)
            obj.helpStruct.blocktol = ...
                'Tolerance level for setting elements of the jacobian to zero when doing block decomposition.';
        end
        
        function obj = blocklags(obj)
            obj.helpStruct.blocklags = ...
                ['The number of lags to include in the exogenous block of the VAR model. Be aware that ''ols'' ',...
                 'is no longer an efficient estimator in this case. Default is empty, i.e. same as the ''nLags'' option.'];
        end

        function obj = block_exogenous(obj)
            obj.helpStruct.block_exogenous = ...
                ['A cellstr with the names of the block_exogenous variables of the model. E.g. ',...
                 '{''Var1'',''Var2''}. Information on this input will be stored in the property ',...
                 'block_exogenous.'];
        end
        
        function obj = bridgedhighfunc(obj)
            obj.helpStruct.bridgedhighfunc = ...
                ['A function handle that is applied to the forecast of the high frequency variable. Be aware ',...
                 'that 20 periods of history is appended to the forecast before this function is applied. ',...
                 'The first and ONLY input is an object of class nb_math_ts. E.g. @(x)pcn(x,3).'];
        end
        
        function obj = bridgedhightransformed(obj)
            obj.helpStruct.bridgedhightransformed = ...
                ['The name of the variable after the transformation are applied (i.e. bridgedHighFunc). ',...
                 'It must only be given, if bridgedHighFunc is set to a function handle and you are doing ',...
                 'reporting, i.e. this is the variable name on the forecast stored after bridging. To be sure ',...
                 'that the history of the variable is corret you need to provide the same transformation with the ',...
                 'use of the transformations property.'];
        end
        
        function obj = bridgedhighvariable(obj)
            obj.helpStruct.bridgedhighvariable = ...
                ['A one line char of the high frequency variable being taken from modelHigh. Default is to use ',...
                 'the first variable found forecasted by modelHigh.'];
        end
        
        function obj = bridgedlowfunc(obj)
            obj.helpStruct.bridgedlowfunc = ...
                ['A function handle that is applied to the forecast of the low frequency variable. Be aware ',...
                 'that 20 periods of history is appended to the forecast before this function is applied. ',...
                 'The first and ONLY input is an object of class nb_math_ts. E.g. @(x)pcn(x).'];
        end
        
        function obj = bridgedlowvariable(obj)
            obj.helpStruct.bridgedlowvariable = ...
                ['A one line char of the low frequency variable being taken from modelLow. Default is to use ',...
                 'the first variable found forecasted by modelLow.'];
        end
        
        function obj = calibrater(obj)
            obj.helpStruct.calibrater = ...
                ['This input makes it possible to calibrate the measurement error covariance matrix. It must ',...
                 'be given as a cell array with length 2*nCalib, where nCalib is the number of calibrated ',...
                 'observed variables. E.g. {''Var1'',100,''Var2'',inf}, i.e. every second element starting ',...
                 'with the first element must be the name of the observed variable, and every second element ',...
                 'must be a scale parameter. The associated measurement error parameter is constructed by ',...
                 'dividing the variance of the calibrated observed variable by the scaling parameters. So ',...
                 'use inf to set measurement error to 0. Calibration is only used during conditional forecasting!'];
        end
        
        function obj = check(obj)
            obj.helpStruct.check = ...
                ['A logical (true/false) option that decides whether or not try to check for trivial mistakes ',...
                 'in the model. For example test for equations given multiple times.'];
        end
        
        function obj = class(obj)
            obj.helpStruct.class = ...
                ['The model class. ''nb_var'': Test VARs with different combination of variables and lag length, ',...
                 'and select the best performing models when it comes to forecasting. ''nb_arima'': ',...
                 'Test ARIMAs with different combination of AR and MA terms, and select the best ',...
                 'performing models when it comes to forecasting.'];
        end
        
        function obj = comparetorev(obj)
            obj.helpStruct.comparetorev = ...
                ['Which revision to compare to. Default is first release, i.e. 1. Give 5 to get fifth release. ',...
                 'Must be an integer. 0 means you compare to the final vintage, instead of any release series.'];
        end
        
        function obj = condhorizon(obj)
            obj.helpStruct.condhorizon = ...
                ['Sets the max number of periods to condition on the forecast of a list of variables. Must be ',...
                 'a N x 2 cell array. Each element of the first column must contain the name of the variable, and ',...
                 'each element of the second column must be an integer. Each variable not provided will use all, ',...
                 'available conditional information for that variable. Caution: If you set a variable to use 4 ',...
                 'periods, but it has only conditional information for 2, this will not change anything, and no ',...
                 'warning or error will be thrown either!'];
        end
        
        function obj = condlags(obj)
            obj.helpStruct.condlags = ...
                ['Number of lags included in the calcualtion of the (auto)correlation matrix used when ',...
                 '''density'' is set to true and ''method'' is set to ''copula''. I.e. the number of ',...
                 'periods to "condition on". This option should only be used if the forecast densities to be ',... 
                 'aggregated are not condition on information up until the time of the forecast. This is not ',...
                 'the normal case, so default is 0.'];
        end
        
        function obj = constant(obj)
            obj.helpStruct.constant = ...
                ['A binary option that decides whether or not there will be a constant term in the model. ',...
                 'If a constant term is added, it will be the first variable on the right hand side.'];
        end
        
        function obj = constraints(obj)
            obj.helpStruct.constraints = ...
                'A N x 1 cellstr with the non-linear constraint on the pameters. E.g. {''param3 + param4 = 1''}. ';
            if strcmpi(obj.typeName,'class')
                obj.helpStruct.equations = [obj.helpStruct.equations,...
                    'Can also be supplied by a model file, see nb_nonLinearEq.parse.'];
            end 
        end
        
        function obj = contemporaneous(obj)
            obj.helpStruct.contemporaneous = ...
                ['A binary option that decides whether or not there will be a contemporaneous factor term in ',...
                 'the forecasting equation of the model. Default is 0.'];
        end
        
        function obj = convertforecastoptions(obj)
            obj.helpStruct.convertforecastoptions = ...
                ['Sets the options on how to convert the forecasted variables from the given model. Must ',...
                 'be assign a nb_convertForecastVintagesOptions array of same length as inVariables.'];
        end
        
        function obj = convertfrequency(obj)
            obj.helpStruct.convertfrequency = ...
                ['Set to a scalar integer to convert the data to a lower frequency than used during ',...
                 'transformations.'];
        end
        
        function obj = convertmethods(obj)
            obj.helpStruct.convertmethods = ...
                ['Set the method to use if the convertFrequency option is used. Must either be a one line ',...
                 'char with the method to apply to all series or a cellstr on the format {''Var1'',''average'',',...
                 '''Var2'',''sum''}. The variables not provided will get the default method assign. See the ',...
                 'nb_ts.convert for the supported methods.'];
        end
        
        function obj = cores(obj)
            obj.helpStruct.cores = ...
                ['If parallel option is set to true, this option can be used to set the number of cores to ',...
                 'run in parallel. Default is to use all cores available.'];
        end
        
        function obj = crit(obj)
            obj.helpStruct.crit = ...
                ['Number of models to pick from the model selection, i.e. the best 10 models. E.g. 10. ',...
                 'Default is 10.'];
        end
        
        function obj = criterion(obj)
            obj.helpStruct.criterion = ...
                ['The Criterion option decides the information criteria used for automatic lag length selection. ',...
                 'The possible options are Akaike (''aic''), Modified Akaike (''maic''), Schwartz (''sic''), ',...
                 'Modified Schwartz (''msic''), Hannan-Quinn (''hqc'') or Modified Hannan Quinn (''mhqc'').'];
        end
        
        function obj = covrepair(obj)
            obj.helpStruct.covrepair = ...
                ['A logical (true/false) option that decides whether or not try to repair the covariance matrix '...
                 'of the estimated residual or the parameters estimates when it result in a non-positive definite ',...
                 'matrix. Default is false.'];
        end
        
        function obj = data(obj)
            
            if strcmpi(obj.typeName,'package')
                obj.helpStruct.data = ...
                	['A nobs x nvar double with the data that may be used for estimation. See also dataStartDate, dataTypes ',...
                     'and dataVariables.'];
            else
            
                switch lower(obj.dataType)
                    case 'timeseries'
                        obj.helpStruct.data = ...
                            ['The data option holds the data as a nb_ts object for time-series models. May be multi-paged, if the ',...
                             'real_time_estim option is set to true.'];
                    case 'crosssectional'
                        obj.helpStruct.data = ...
                            'The data option holds the data as a nb_cs object for models of cross sectional data.';
                    otherwise
                        obj.helpStruct.data = ...
                            ['The data option holds the data as a nb_ts (time series) or nb_cs (cross sectional) object. May be a ',...
                             'multi-paged nb_ts object, if the real_time_estim option is set to true.'];
                end
                
            end
            
        end
        
        function obj = datasource(obj)
            if strcmpi(obj.nameOfPOrC,'nb_bridge_forecast_vintages.aggregateForecast')
                obj.helpStruct.datasource = ...
                    ['A nb_modelDataSource object that contain the real-time data of the series to be bridged (i.e. ',...
                     'the high frequency series). It is used for plotting and evaluating the forecast.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.datasource = ...
                    ['A nb_modelDataSource object that contain the real-time data of the series to be aggregated. ',...
                     'It is used for plotting and evaluating the forecast.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.combineForecast')
                obj.helpStruct.datasource = ...
                    ['A nb_modelDataSource object that contain the real-time data of the series to be combined. ',...
                     'In the case the ''transformations'' property is set, it can contain the variables needed ',...
                     'to construct the series to be combined. You can use this option to speed up the process of ',...
                     'locating the historical data of the series to combine, i.e. instead of loading them up from ',...
                     'the models of the group.'];
            else
                obj.helpStruct.datasource = ...
                    'A nb_modelDataSource object that contain the real-time data to use.';
            end
        end
        
        function obj = datastartdate(obj)
            
            switch lower(obj.dataType)
                case 'timeseries'
                    obj.helpStruct.datastartdate = ...
                        ['The start date of the assign data. This input must be of the format dd.mm.yy, ddmmyy, ',...
                         'yyyyMm(m)d(d), yyyyWw(w), yyyyMm(m), yyyyQq(q), yyyyKk(k) or yyyy.'];
                case 'both'
                    obj.helpStruct.datastartdate = ...
                        ['The start date of the assign data. Can be empty if cross-sectional is used. See dataTypes. ',...
                         'This input must be of the format dd.mm.yy, ddmmyy, yyyyMm(m)d(d), yyyyWw(w), yyyyMm(m), yyyyQq(q), ',...
                         'yyyyKk(k) or yyyy.'];
            end
            
            
        end
        
        function obj = datatypes(obj)
            obj.helpStruct.datatypes = ...
                'A 1 x nobs cellstr with the types of the data option (in the case of cross-sectional data).';
        end
        
        function obj = datavariables(obj)
            obj.helpStruct.datavariables = ...
                'A 1 x nvar cellstr with the variables of the data option.';
        end
        
        function obj = density(obj)
            obj.helpStruct.density = ...
                ['Give true if you want to  produce density forecast. Default is not (false). ',...
                 'Caution: If you set this option to false the mean forecast is used to '
                 'construct the point forecast from model which has produced density forecast.'];
        end
        
        function obj = density_estim(obj)
            obj.helpStruct.density_estim = ...
                ['A struct storing the settings for estimating the densities of the data. See the ',...
                 'nb_pit_model_generic.densityEstimationOptions method.'];
        end
        
        function obj = dependent(obj)
            
            if strcmpi(obj.typeName,'class')
                if strcmpi(obj.nameOfPOrC,'nb_exprModel')
                    obj.helpStruct.dependent = ...
                        ['A cellstr with the expression of the left hand side variable of each equation of the model. ',...
                         'E.g. {''diff(Var1(t))''}. Information on this input will be stored in the property dependent. ',...
                         'Only the functions ''log(x(t))'', ''exp(x(t))'', ''diff(x(t))'', and ''growth(x(t))'' are ',...
                         'supported for forecasting. For the the dependent variable the expression can only contain one ',...
                         'variable and it has to be dated at time t.'];
                else
                    obj.helpStruct.dependent = ...
                        ['A cellstr with the name(s) of the dependent variable(s) of the model. E.g. ',...
                         '{''Var1''}. Information on this input will be stored in the property dependent.'];
                end
            else
                obj.helpStruct.dependent = ...
                    ['A cellstr with the name(s) of the dependent variable(s) of the model. E.g. ',...
                     '{''Var1''}.'];
            end
            
            switch lower(obj.nameOfPOrC)
                case 'nb_arima'
                    extra = ' Each dependent variable will result in a separate equation.';
                case 'nb_ecm'
                    extra = ' Should only contain the (one) left hand-side level variable of the ECM model.';
                case 'nb_nonlineareq'
                    extra = ' Can also be supplied by a model file, see nb_nonLinearEq.parse.';
                case 'nb_var'
                    extra = ' Each dependent variable will result in a seperate equation.';
                otherwise
                    extra = '';
            end
            obj.helpStruct.dependent = [obj.helpStruct.dependent,extra];
            
        end
        
        function obj = derivativemethod(obj)
            obj.helpStruct.derivativemethod = ...
                'Either ''automatic'' or ''symbolic''.';
        end
        
        function obj = discount(obj)
            obj.helpStruct.discount = ...
                ['A 1 x N struct with fields ''eq'', ''value'' and ''name''. At field ''eq'' you need ',...
                'to provide the equation number, numbers or ''all'' (all equations) associated ',...
                'with the given discount factor. At field ''value'' you must provide the value of ',...
                'the discount factor for the associated equations or nan. In the case nan is given ',...
                'to ''value'' ''name'' must contain the name of th parameter that the discount factor ',...
                'is assign to, otherwise set ''name'' to ''''.'];
        end
        
        function obj = distribution(obj)
            obj.helpStruct.distribution = ...
                ['Set the distribution to use when you try to map forecasted percentiles from models ',...
                 'estimated with quantile methods. Either ''kernel'' or one of the distributions mentioned ',...
                 'in the doc of the nb_distribution.type property. For the last distribution you need at least ',...
                 'as many percentiles as there are parameters. The process is as follows, first estimate the ',...
                 'distribution, then simulate from it. Number of simulations are provided by the ''draws'' ',...
                 'option.'];
        end
        
        function obj = dotests(obj)
            obj.helpStruct.dotests = ...
                'Either 1 (true) to do the automatic tests, or 0 (false) to skip them.';
        end
        
        function obj = draws(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.draws = ...
                    'See help on the ''draws'' input to the nb_model_generic.forecast method.';
            elseif strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.draws = ...
                    ['Number of draws from the marginal distributions of the disaggregated models ',...
                     'to base the new aggrgated density forecast on. Default is 1000.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.combineForecast')
                obj.helpStruct.draws = ...
                    'Number of draws from the combine density. Default is 1000.';     
            elseif strcmpi(obj.nameOfPOrC,'nb_dsge')
                obj.helpStruct.draws = ...
                ['Number of posterior draws using the selected sampling algorithm. Default is 0, i.e. only return ',...
                 'the mode when calling the estimate method.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_midas') || strcmpi(obj.nameOfPOrC,'nb_midasestimator')
                obj.helpStruct.draws = ...
                    ['A integer with the number of bootstrapped parameters for constructing standard errors. The ',...
                     'draws maid here will also be used for density forecast etc. Default is 1000. Set it to 1 ',...
                     'or smaller to not do any bootstrapping.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
                obj.helpStruct.draws = ...
                    ['Number of residual draws when producing density forecast. If set to 1, point forecast ', ...
                     'are made.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_tvp')
                obj.helpStruct.draws = ...
                    'A integer with the number of draws from the posterior when doing bayesian estimation.';
            elseif strcmpi(obj.nameOfPOrC,'nb_var') || strcmpi(obj.nameOfPOrC,'nb_bVarEstimator')
                obj.helpStruct.draws = ...
                    ['A integer with the number of draws of Monte Carlo integration or Gibbs sampler when doing '...
                     'bayesian estimation.'];
            else
                obj = notDocumented(obj,'draws'); 
            end
            
        end
        
        function obj = dummyfuncs(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages') || strcmpi(obj.nameOfPOrC,'nb_calculate_vintages')
                obj.helpStruct.dummyfuncs = ...
                    ['A cell array with function_handle object on how to add dummy variables to the data. ',...
                     'The supported dummies are; @easterDummy and @covidDummy. E.g. {@covidDummy}. Caution: If ',...
                     'you use the createTimeDummy method it is important to not use the condition input set to ''>'' ',...
                     'or ''>='', as the forecast of time dummies are zeros. Instead use ''<='' and ''<'' ',...
                     'respectivly (is empirically equivalent). The name of the time dummies must start with ',...
                     'timeDummy. E.g. {@(x)createTimeDummy(x, ''timeDummy1'', ''2014Q1'', ''<'')}'];
            else
                obj = notDocumented(obj,'dummyfuncs'); 
            end
            
        end
        
        function obj = empirical(obj)
            obj.helpStruct.empirical = ...
                ['Set this option to true to do empirical bayesian estimation, i.e. maximize ',...
                 'over the hyperparameters. Only possible for a normal-whishart type priors. ',...
                 'See Giannone, Lenza and Primiceri (2014), "Prior selection for vector ',...
                 'autoregressions" for algorithm, and see nb_bVarEstimator.doEmpiricalBayesian ',...
                 'for implementation. If you are dealing with missing observations, only ',...
                 'the full balanced sample is used for the optimization step, but.'];
        end
        
        function obj = enddate(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.enddate = ...
                    ['End date of the aggregation of forecast. Default is to use the last shared run date. ',...
                     'Must be given as a string that can be given to the nb_day constructor or a nb_day ',...
                     'object.'];
            else
                obj.helpStruct.enddate = ...
                    ['This will be the end date of recursive forecast. Default is to produce recursive forecast ',...
                     'until ''estim_end_date'' + 1. Must be a char or a nb_date object.'];
            end
            
        end
        
        function obj = endogenous(obj)
            
            if strcmpi(obj.typeName,'class')
                obj.helpStruct.endogenous = ...
                    ['A cellstr with the name(s) of the endogenous variable(s) of the model. E.g. ',...
                     '{''Var1''}. Information on this input will be stored in the property endogenous.'];
            else
                obj.helpStruct.endogenous = ...
                    ['A cellstr with the name(s) of the endogenous variable(s) of the model. E.g. \n',...
                     '{''Var1''}.'];
            end

            switch lower(obj.nameOfPOrC)
                case 'nb_ecm'
                    extra = 'These are the variables to be included in the cointegrated relation.';
                otherwise
                    extra = '';
            end
            obj.helpStruct.endogenous = [obj.helpStruct.endogenous,extra];
            
        end
        
        function obj = equations(obj)
            
            obj.helpStruct.equations = ...
                ['A 1 x 1 cellstr with the non-linear equation to estimate. E.g. ',...
                 '{''y = param1 + param2*(param3*x1 + param4*x2)''}. '];
            if strcmpi(obj.typeName,'class')
                obj.helpStruct.equations = [obj.helpStruct.equations,...
                    'Can also be supplied by a model file, see nb_nonLinearEq.parse.'];
            end
             
        end
        
        function obj = estdensity(obj)
            obj.helpStruct.estdensity = ...
                'See help on the ''estDensity'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = estim_end_date(obj)
            obj.helpStruct.estim_end_date = ...
                ['This option is the final observation that will be included in the estimation. ',...
                 'It must be a one line char on the format dd.mm.yy, ddmmyy, yyyyMm(m)d(d), yyyyWw(w), ',...
                 'yyyyMm(m), yyyyQq(q), yyyyKk(k) or yyyy, or it may be a nb_date object. The input date cannot ',...
                 'be before the estim_start_date. This should not be set if you want the model group to be ',...
                 'updatable.'];
        end
        
        function obj = estim_end_ind(obj)
            obj.helpStruct.estim_end_ind = ...
                ['The estim_end_ind option is the final observation that will be included in the estimation. ',...
                 'As an integer. Must be less than size(data,1) and greater than estim_start_ind.'];
        end
        
        function obj = estim_start_date(obj)
            obj.helpStruct.estim_start_date = ...
                ['This option is the first observation that will be included in the estimation. ',...
                 'It must be a one line char on the format dd.mm.yy, ddmmyy, yyyyMm(m)d(d), yyyyWw(w), ',...
                 'yyyyMm(m), yyyyQq(q), yyyyKk(k) or yyyy, or it may be a nb_date object. The input date cannot ',...
                 'be after the estim_end_date. Default is empty. I.e. start at the first possible date, ',...
                 'i.e. where the model(s) is/are balanced.' ];
        end
        
        function obj = estim_start_ind(obj)
            obj.helpStruct.estim_start_ind = ...
                ['The estim_start_ind option is the first observation that will be included in the estimation. ',...
                 'As an integer. Must be less than estim_end_ind and greater than 0.'];
        end
        
        function obj = estim_method(obj)
            
            obj.helpStruct.estim_method = ...
                'The estim_method option decides what kind of estimation that will be performed.';
            switch lower(obj.nameOfPOrC)
                case {'nb_ecm','nb_sa'}
                    extra = ' The only supported is ordinary least squares (''ols''). See nb_olsEstimator.estimate.';
                case {'nb_favar','nb_fm''nb_fmsa'}
                    extra = [' The only supported is ''fm''. The factors are estimated using principal component (nb_pca) ',...
                             'and the main model using ordinary least squares. See nb_fmEstimator.estimate.'];
                case 'nb_fmdyn'
                    extra = [' Expected maximum likelihood (''dfmeml'') or bayesian methods (''bdfm''). See doc of the ',...
                            'nb_fmdyn for more on these algorithms. Priors for the bayesian methods can be set by using ',...
                            'nb_fmdyn.priorTemplate and nb_fmdyn.setPrior methods.'];
                case 'nb_mfvar'
                    extra = [' This options should not be set. It will be ''ml'' (maximum likelihood) if the prior option \n',...
                             'is empty, otherwise it will be set to ''bVar'' (bayesian VAR). See nb_mlEstimator.estimate and ',...
                             'nb_bVarEstimator.estimate respectively.'];
                case 'nb_midas'
                    extra = [' The only supported is the midas estimator (''midas''). See nb_midasEstimator.estimate. ',...
                             '(See the algorithm input to set which type of MIDAS model you want).'];
                case 'nb_nonlineareq'
                    extra = ' The only supported is non-linear least squares (''nls'').';
                case 'nb_pitvar'
                    extra = [' The only supported is PIT-VAR estimation (''pit''). This will first estimate a distribution on ',...
                             'each of the series before it maps those to be N(0,1). The VAR will then be estimated on these latent ',...
                             'series, while the final result will be reported back to the original series. This may allow for ',...
                             'non-linear effect of shocks and therefore skewed forecast distributions.'];
                case 'nb_singleeq'
                    extra = [' Ordinary least squares (''ols''), two stage least squares (''tsls''), quantile regression (''quantile''), ',...
                             'least absolute shrinkage and selection operator (''lasso'') or ridge regression (''ridge'').'];
                case 'nb_var'
                    extra = [' The supported options are; ordinary least squares (''ols'') , bayesian VAR estimation (''bVar'') ',...
                             ', maximum likelihood estimation (''ml''), least absolute shrinkage and selection operator (''lasso'') ',...
                             'or ridge regression (''ridge''). If the prior option is set, this option will automatically ',...
                             'be set to ''bVar''.'];
                case 'nb_calculate_factors'
                    extra = ' The supported options are; principal component (''pca''), whitening (''whiten'').';   
                case 'nb_calculate_seasonal'
                    extra = ' The supported option is; seasonal adjustment (''seasonal'').';      
                otherwise
                    extra = ' Sorry, the methods to choose from are not documented.';
            end                          
            obj.helpStruct.estim_method = [obj.helpStruct.estim_method,extra];
            
        end
        
        function obj = estim_steady_state_solve(obj)
            obj.helpStruct.estim_steady_state_solve = ...
                ['If this options is set to false, the steady state is not solved for at each iteration during ',...
                 'estimation. Default is true. Caution: If set to false, the steady-state must be solved for ',...
                 'before calling the estimate method!'];
        end
        
        function obj = estim_types(obj)
            obj.helpStruct.estim_types = ...
                ['Sets the types to be included in the estimation. If the data of the model ',...
                 'is not a nb_cs (cross-sectional data) object, this option will not be used.'];
        end
        
        function obj = estim_verbose(obj)
            obj.helpStruct.estim_verbose = ...
                ['If this options is set to true, nb_dsge.objective method tries to display information on why it ',...
                 'fails to evaluate the objective. Default is false.'];
        end
        
        function obj = estimatedensities(obj)
            obj.helpStruct.estimatedensities = ...
                'See help on the ''estimateDensities'' input to the nb_model_generic.forecast method. Default is false.';
        end
        
        function obj = exogenous(obj)
            
            if strcmpi(obj.typeName,'class')
                if strcmpi(obj.nameOfPOrC,'nb_exprModel')
                    obj.helpStruct.exogenous = ...
                        ['A cellstr with the expressions of the right hand side variables the equations of the model. ',...
                         'E.g. {''diff(Var1(t-1))''} or {{''diff(Var1(t-1))''}, {''diff(Var2(t))''}}. In the first case it is assumed ',...
                         'that the right hand side variables are the same for all equations. While in the last example the ',...
                         'first element will be the right hand side expression of the first equation, while the second will be the same ',...
                         'for equation 2. Information on this input will be stored in the property exogenous. Any function ',...
                         'that works on a double and return the same length as its inputs are supported. Examples are ''log(x(t))'' ',...
                         'and ''x(t)-y(t)''. You can date right hand side variables with (t) or (t-s), where s is a strictly ',...
                         'positive number.'];
                else
                    obj.helpStruct.exogenous = ...
                        ['A cellstr with the name(s) of the exogenous variable(s) of the model. E.g. ',...
                         '{''Var1'',''Var2''}. Information on this input will be stored in the property exogenous.'];
                end
            else
                obj.helpStruct.exogenous = ...
                    ['A cellstr with the name(s) of the exogenous variable(s) of the model. E.g. ',...
                     '{''Var1'',''Var2''}.'];
            end

            switch lower(obj.nameOfPOrC)
                case 'nb_ecm'
                    extra = ['Should only contain the right hand-side that are not in the cointegration relation, and that ',...
                            'are not be differenced automatically, i.e. purly exogenous variables.'];
                case 'nb_nonlineareq'
                    extra = ' Can also be supplied by a model file, see nb_nonLinearEq.parse.';        
                otherwise
                    extra = '';
            end
            obj.helpStruct.exogenous = [obj.helpStruct.exogenous,extra];
              
        end
        
        function obj = exolags(obj)
            obj.helpStruct.exolags = ...
                ['Setting exoLags will set the amount of lags used in the regression. Either a scalar ',...
                 'integer, which will act on all exogenous variables, a vector of integers with the same ',...
                 'length as the ''exogenous'' option or a cell array with the same length as the ',...
                 '''exogenous'' option, where each element is a scalar or vector of integers with ',...
                 'the lag structure of each exogenous variable.'];
        end
        
        function obj = exoproj(obj)
            obj.helpStruct.exoproj = ...
                'See help on the ''exoProj'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = exoprojar(obj)
            obj.helpStruct.exoprojar = ...
                'See help on the ''exoProjAR'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = exoprojcalib(obj)
            obj.helpStruct.exoprojcalib = ...
                'See help on the ''exoProjCalib'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = exoprojdiff(obj)
            obj.helpStruct.exoprojdiff = ...
                'See help on the ''exoProjDiff'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = exoprojdummies(obj)
            obj.helpStruct.exoprojdummies = ...
                'See help on the ''exoProjDummies'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = exoprojhist(obj)
            obj.helpStruct.exoprojhist = ...
                'See help on the ''exoProjHist'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = factorrestrictions(obj)
            obj.helpStruct.factorrestrictions = ...
                ['Set this option to false to prevent zero restrictions on lags of other factors, ',...
                 'i.e. assume that the factors follows a VAR(nLags) instead of uncorrelated ',...
                 'AR(nLags) processes. If set to false no restriction on the covariance matrix ',...
                 'is applied either.'];
        end
        
        function obj = factors(obj)
            obj.helpStruct.factors = ...
                'Prefilter the endogenous variables of the VAR with a set of factors. Must be given as a cellstr.';
        end
        
        function obj = factorscriterion(obj)
            obj.helpStruct.factorscriterion = ...
                ['Sets the selection criterion to use to get the number of used factors. Must be set '...
                 'to a number between 1 and 7. See the optional input ''crit'' to the nb_pca method for more. '...
                 'This option is overruled by the nFactors option.'];
            if strcmpi(obj.nameOfPOrC,'nb_calculate_factors')
                obj.helpStruct.factorscriterion = [obj.helpStruct.factorscriterion,...
                    ' Only supported when the estim_method options is set to ''pca''.'];
            end
             
        end
        
        function obj = factorslags(obj)
            obj.helpStruct.factorslags = ...
                ['Sets the number of lags of the factor VAR part of the dynamic factor model. Must be a '...
                 'scalar integer.'];
        end
        
        function obj = fcstdb(obj)
            obj.helpStruct.fcstdb = ...
                ['Assign a nb_manualDataSource object that return one variable. Each context provide a set '...
                'of forecast. The last not nan observation of the dataSource option + 1 period is taken as ',...
                'the start date of the forecast from this data source. See the var2Merge options for more info.'];
        end
        
        function obj = fcsteval(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages') || strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast') || strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.combineForecast')
                obj.helpStruct.fcsteval = ...
                    ['See help on the ''fcsteval'' input to the nb_model_generic.forecast method. These are '...
                     'the evaluation methods calculated when the evaluateForecast or update methods are called.'];
            else
                obj.helpStruct.fcsteval = ...
                    'See help on the ''fcsteval'' input to the nb_model_generic.forecast method.';
            end
            
        end
        
        function obj = fcstvar(obj)
            obj.helpStruct.fcstvar = ...
                'The variable of interest, i.e. storing the forecast to base the fan chart upon. As a one line char.';
        end
        
        function obj = fix_point_dampening(obj)
            obj.helpStruct.fix_point_dampening = ...
                ['Dampening factor for fixed point problems. A number between 0 and 1. ',...
                 'Default is 1, i.e. no dampening.'];
        end
        
        function obj = fix_point_maxiter(obj)
            obj.helpStruct.fix_point_maxiter = ...
                'Maximum number of iteration when using fixed point algorithms. Default is may depend on class/package.';
        end
        
        function obj = fix_point_TolFun(obj)
            obj.helpStruct.fix_point_TolFun = ...
                'Criteria for acception a solution of a fixed point problem. Default is 1e-05.';
        end
        
        function obj = fix_point_verbose(obj)
            obj.helpStruct.fix_point_verbose = ...
                'Set it to true to report the status during fixed point iteration.';
        end
        
        function obj = flak(obj)
            obj.helpStruct.flak = ...
                'Logical, either 1 or 0. Indicates whether the model will be used in produsing a flak, or not.';
        end
        
        function obj = freq(obj)
            obj.helpStruct.freq = ...
                'The frequency to convert to as an integer. 1 (yearly), 4 (quarterly) and 12 (monthly).';
        end
        
        function obj = folder(obj)
            obj.helpStruct.folder = ...
                'Set the folder for where to save model output to, and where to throw errors.';
        end
        
        function obj = frequency(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_mfvar') || strcmpi(obj.nameOfPOrC,'nb_mlestimator')
                obj.helpStruct.frequency = ...
                    ['This options sets the frequency of the dependent and/or the block exogenous variables of ',...
                     'the model. Supported frequencies are 1 (yearly), 4 (quarterly), 12 (monthly) and 52 ',...
                     '(weekly). There is no need to set the frequency of the variables with the same frequency as ',...
                     'the supplied data. See also the setFrequency method.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_fmdyn')
                obj.helpStruct.frequency = ...
                    ['This options sets the frequency of the observed variables (observables) of ',...
                     'the model. Supported frequencies are 4 (quarterly) or 12 (monthly). There is ',...
                     'no need to set the frequency of the variables with the same frequency as the supplied data. ',...
                     'See also the setFrequency method.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_midas') || strcmpi(obj.nameOfPOrC,'nb_midasestimator')
                obj.helpStruct.frequency = ...
                    ['When set to an integer, this sets the frequency of the dependent variable. 1 (yearly), 4 (quarterly) ',...
                     'or 12 (Monthly). The frequency of the data options will be the frequency of the regressors in the ',...
                     'case frequency is set to an integer. When set to a cell array it can set the frequency of the dependent ',...
                     'and the exogenous variables of the model. Supported frequencies are 1 (yearly), 4 (quarterly), 12 ',...
                     '(monthly) and 52 (weekly). There is no need to set the frequency of the variables with the same ',...
                     'frequency as the supplied data. See also the setFrequency method.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_vintages') || strcmpi(obj.nameOfPOrC,'nb_calculate_vintages')
                obj.helpStruct.frequency = ...
                    ['Sets the frequency of each of the variables listed in varOfInterest. Supported frequencies ',...
                     'are 1 (yearly), 4 (quarterly) or 12 (monthly). This option must be set if you set the model ',...
                     'option to an object of class nb_mfvar (and only then). E.g. [4,12], where we in this example ',...
                     'want to report the forecast of the first variable with quarterly frequency, while the second ',...
                     'variable with monthly frequency.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_convert_forecast_vintages')
                obj.helpStruct.frequency = ...
                    ['Sets the frequency to convert the forecast to. Supported frequencies are 1 (yearly), 4 (quarterly) ',...
                     'or 12 (monthly).'];
            else
                obj = notDocumented(obj,'frequency'); 
            end
            
        end
        
        function obj = func(obj)
            obj.helpStruct.func = [...
                'Set the function to be called on the shortened data. It should only take one input, and this is a T x N ',...
                'nb_math_ts object, and output another T2 x M nb_math_ts object. The order of the input object is decided ',...
                'by the dependent option. You need to provide the names of the output variables by the outVariables option!'];
        end
        
        function obj = getobjectivefunc(obj)
            obj.helpStruct.getobjectivefunc = ...
                ['A function (handle) that has the following syntax [fh,estStruct,lb,ub,opt,options] = getObjectiveFunction(options) ',...
                 'fh is the objective to minimize, lb is the lower bound on the parameters to estimate, ub is the upper bound ',...
                 'on the parameters to estimate, opt is the options given to the optimizer and options is the same as the input ',...
                 'options (i.e. to allow for changes). The estStruct is a struct with estimation options. It must at least ',...
                 'have the fields beta (full set of parameters of the model) and indPar (the index for where to locate the ',...
                 'the estimated parameters in beta.)'];
        end
        
        function obj = handlemissing(obj)
            obj.helpStruct.handlemissing = ...
                ['If set to true, the estim_start_date options is set to the date of the first observation of ANY variable, ',...
                 'instead of the the date for where ALL variables has valid observations. The same applies to estim_end_date, ',...
                 'but in this case we are doing it for the the last observation.'];
        end
        
        function obj = homotopyalgorithm(obj)
            obj.helpStruct.homotopyalgorithm = ...
                ['Set this to 1, 2 or 3 to use the homotopy approach for solving a system of non-linear ',...
                 'equations recursivly. For more on the this option see nb_homotopy function. If equal ',...
                 'to 0, there is no use of homotopy.'];
        end
        
        function obj = homotopysetup(obj)
            obj.helpStruct.homotopysetup = ...
                ['Sets the homotopy finish values for the parameters when a homotopy algorithm is ',...
                 'used. A N x 2 cell matrix. Each row must be {paramName,finish}. paramName must be a ',...
                 'one line char with the name of the parameter to change. finish is the value of the ',...
                 'parameter where we want to solve the problem. The start point of the homotopy alogorithm ',...
                 'is assumed to come from the given calibration, where it is assumed that we already now ',...
                 'how to solve the problem.'];
        end
        
        function obj = homotopysteps(obj)
            obj.helpStruct.homotopysteps = ...
                ['Sets the homotopy steps. Will depend on the homotopyAlgorithm selected. For more see ',...
                 'nb_homotopy function.'];
        end
        
        function obj = hyperprior(obj)
            obj.helpStruct.hyperprior = ...
                ['Set it to true to use hyperpriors when doing empirical bayesian. See the empirical',...
                 'options. The default hyperpriors are given by the nb_var.priorTemplate method.'];
        end
        
        function obj = hyperlearning(obj)
            obj.helpStruct.hyperlearning = ...
                ['Set to true to use 1-step ahead forecast error score to optimize hyper-parameters. ',...
                 'The type of score to use can be set by the hyperLearningSettings option. '];
        end
        
        function obj = hyperlearningsettings(obj)
            obj.helpStruct.hyperlearningsettings = ...
                ['Sets the settings used for hyper parameter optimization based on 1-step ahead forecast score. ',...
                 'The ''type'' field must be set to ''RMSE'' (root mean squared errors). The ''startScorePerc'' ',...
                 'sets how big the scoring sample should be as a percentage of the estimation sample. Default ',...
                 'is to use 50% (i.e. by setting it to 0.5). The last field is ''variable''. Here you can set ',...
                 'the variable you want to evaluate the forecast performance of. If empty, the first variable ',...
                 'listed by the dependent variables of the model is used!'];
        end
        
        function obj = instruments(obj)
            obj.helpStruct.instruments = ...
                ['The instrument property allows you to set instruments for endogenous variables in two stage least ',...
                 'square estimation. The input must take the format (''endoVar1'', {''instr1'',''instr2''},''endoVar2'',{''instr3''}) ',...
                 'and so on.'];
        end
        
        function obj = integration(obj)
            obj.helpStruct.integration = ...
                'Sets the degree of integration for ARIMA estimation. As a scalar integer >0.';
        end
        
        function obj = interpolatedate(obj)
            obj.helpStruct.interpolatedate = ...
                ['Either ''start'' or ''end''. Date of interpolation. Where ''start'' means to interpolate ',...
                 'the start date of the periods of the old frequency, while ''end'' uses the end date ',...
                 'of the periods. Default is ''start''. Caution: Only when converting to a higher frequency.'];
        end
        
        function obj = infuncs(obj)
            obj.helpStruct.infuncs = ...
                ['Sets the transformation applied to each forecasted variable before converting the frequency. ',... 
                 'Either {} (no transformation), or a cell array of function handles or empty elments. The cell ',...
                 'array must have same length as the inVariables, and the transformation of element i applies to ',...
                 'the i-th element of inVariables.'];
        end
        
        function obj = init(obj)
            obj.helpStruct.init = ...
                ['The init option sets the inital conditions of the estimation (optimizing). A struct, where the parameter ',...
                 'names must be the fieldnames and the inital value of those are the fields. The parameters that are not set ',...
                 'gets inital value of 0.'];
        end
        
        function obj = invariables(obj)
            obj.helpStruct.invariables = ...
                'A cellstr with the variable names to convert from the provided model.';
        end
        
        function obj = kf_init_variance(obj)
            obj.helpStruct.kf_init_variance = ...
                ['Harvey scale factor, i.e. the initial scale factor of the variance that is used by the ',...
                 'Kalman filter. Default is no scaling, i.e. 1.'];
        end
        
        function obj = kf_kalmantol(obj)
            obj.helpStruct.kf_kalmantol = ...
                'The kalman tolerance. Default is eps. Only when solved with NB toolbox.';
        end
        
        function obj = kf_method(obj)
            obj.helpStruct.kf_method = ...
                ['The kalman method used. Either ''normal'' or ''diffuse''. Default is ''normal''. Use '...
                 '''diffuse'' if you have trends in your model. Only when solved with NB toolbox.'];
        end
        
        function obj = kf_presample(obj)
            obj.helpStruct.kf_presample = ...
                ['The number of periods to discard at the start of the sample when evaluation '...
                 'the likelihood during estimation. Default is 0.'];
        end
        
        function obj = kf_riccatitol(obj)
            obj.helpStruct.kf_riccatitol = ...
                ['The criteria for convergence of the Kalman gain during estimation of methods '...
                 'using the Kalman filter. Only when solved with NB toolbox.'];
        end
        
        function obj = kf_warning(obj)
            obj.helpStruct.kf_warning = ...
                ['Give true to just give a warning if the initial value of the one step forecast ',...
                 'error covariance matrix could not be calculated. It will then proceed with the ',...
                 'identity matrix. Use ''kf_init_variance'' to scale as in the usual case!. Only ',...
                 'when solved with NB toolbox.'];
        end
        
        function obj = lambda(obj)
            if strcmpi(obj.nameOfPOrC,'nb_calculate_hp') || strcmpi(obj.nameOfPOrC,'nb_hpestimator')
                obj.helpStruct.lambda = 'The hp-filter smoothing parameter. Default is 1600.';
            else
                obj.helpStruct.lambda = ...
                    ['Give the value of the parameter of the exponential decaying weights on past forecast ',... 
                     'errors when constructing the score. If empty the weights on all past forecast errors ',...
                     'are equal.'];
            end
        end
        
        function obj = lb(obj)
            obj.helpStruct.lb = ...
                ['The lb option sets the lower bound on the parameters during estimation (optimization). A struct, where ',...
                 'the parameter names must be the fieldnames and the lower bound of those are the fields. The parameters that are ',...
                 'not set gets the lower bound of -inf.'];
        end
        
        function obj = lc_commitment(obj)
            obj.helpStruct.lc_commitment = ...
                ['The probability of commitment used when the model is solved under the assumption of ',...
                 'optimal policy. A number between 0 and 1. Default is 0.'];
        end
        
        function obj = lc_discount(obj)
            obj.helpStruct.lc_discount = ...
                ['The discount factor used when the model is solved under the assumption of optimal ',...
                 'policy, or when applying optimal simple rules. A number between 0 and 1. ',...
                 'Default is 1.'];
        end
        
        function obj = lc_reconvexify(obj)
            obj.helpStruct.lc_reconvexify = ...
                ['If set to true (1) lc_commitment is used in for I_y in equation (10) of ',...
                 'Debortoli, Maih and Nunes (2010), otherwise (lc_commitment>0) is used.'];
        end
        
        function obj = locfcst(obj)
            obj.helpStruct.locfcst = ...
                ['File path for the excel spreadsheet with historical data or the name of the database ',...
                 'for (with extension .db) the forecasts.'];
        end
        
        function obj = lochist(obj)
            obj.helpStruct.lochist = ...
                ['File path for the excel spreadsheet with historical data or the name of the ',... 
                 'database (with extension .db) for the historic data.'];
        end
        
        function obj = m_(obj)
            obj.helpStruct.m_ = ...
                'The M_ output from dynare. Must be combined with oo_ and options_.';
        end
        
        function obj = ma(obj)
            obj.helpStruct.ma = ...
                ['Lets you manually set the number of MA terms of the arima model. Set to nan if you want ',...
                 'the model to select the value for you.'];
        end
        
        function obj = macrowritefile(obj)
            obj.helpStruct.macrowritefile = ...
                ['Give a filename (may include the full path) that the model file after macro processor can be written to. ',...
                 'May be useful for debugging purposes. Will have extension .nbm (if another extension is used this extension ',...
                 'will be changed automitcally!)'];
        end
        
        function obj = macroprocessor(obj)
            obj.helpStruct.macroprocessor = ...
                ['Set this option to true to run the NB Toolbox macro processor before the final ',...
                 'parsing of the model. For more on the macro language see the nb_macro class or ',...
                 'the DAG.pdf documentation.'];
        end
        
        function obj = macrovars(obj)
            obj.helpStruct.macrovars = ...
                ['This options defines the macro variables that can be used in the macro syntax of the model ',...
                 'file. Either as a struct or a vector of nb_macro objects. E.g. to define the variable t, ',...
                 'you can assign this option s = struct(''t'',input) or nb_macro(''t'',input). input can be ',...
                 'double (scalar or vector), logical (scalar or vector), char (multi-line will be converted ',...
                 'to cellstr) or cellstr. For more on the macro language see the nb_macro class or the DAG.pdf ',...
                 'documentation.'];
        end
        
        function obj = mapping(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_bridge_forecast_vintages')
                obj.helpStruct.mapping = ...
                    ['This options sets the mapping used when high frequency variable is bridged with the low ',...
                     'frequency variable. Either ''sum'', ''average'', ''first'' or ''last''. ''average'' is default.'];
            else
                if strcmpi(obj.nameOfPOrC,'nb_fmdyn')
                    var = 'observed variables (observables)';
                else
                    var = 'dependent and/or the block exogenous variables';
                end
                obj.helpStruct.mapping = ...
                    ['This options sets the mapping of the ' var ' of the model.',...
                     'Supported mappings are ''levelSummed'', ''diffSummed'', ''levelAverage'' or ''diffAverage''. ',...
                     'There is no need to set the frequency of the variables with the same frequency as the supplied ',...
                     'data. See also the setMapping method.'];
            end
            
        end
        
        function obj = maxar(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_arima') || strcmpi(obj.nameOfPOrC,'nb_arimaEstimator')
                obj.helpStruct.maxar = ...
                    ['Sets the maximum possible AR terms to be tested when the model estimates the number of AR terms ',...
                     '(i.e. the AR input is nan).'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
                obj.helpStruct.maxar = ...
                    'Set the maximum number of possible AR terms in any of the constructed models. Default is 10.';
            else
                obj = notDocumented(obj,'maxar'); 
            end
            
        end
        
        function obj = maxiter(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_calculate_seasonal') || strcmpi(obj.nameOfPOrC,'nb_seasonalEstimator')
                obj.helpStruct.maxar = 'Sets the maximum iterations of the seasonal adjustment algorithm. Default is 2500.';
            else
                obj = notDocumented(obj,'maxiter'); 
            end
            
        end
        
        function obj = maxlaglength(obj)
            obj.helpStruct.maxlaglength = 'This option sets the maximum amount of lags allowed when lag length is set automatically.';
        end
        
        function obj = maxma(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_arima') || strcmpi(obj.nameOfPOrC,'nb_arimaEstimator')
                obj.helpStruct.maxma = ...
                    ['Sets the maximum possible MA to be tested when the model estimates the number of MA terms ',...
                     '(i.e. the MA input is nan).'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
                obj.helpStruct.maxma = ...
                    'Set the maximum number of possible MA terms in any of the constructed models. Default is 5.';
            else
                obj = notDocumented(obj,'maxma'); 
            end
            
        end
        
        function obj = measurementerror(obj)
            
            obj.helpStruct.measurementerror = ...
                ['A cellstr with the dependent or block exogenous variables that exhibits measurement error. ',...
                 'Only for mixed frequency VAR models (nb_mfvar class) estimated with maximum likelihood.'];
            
        end
        
        function obj = measurementeqrestriction(obj)
            
            obj.helpStruct.measurementeqrestriction = ...
                'Apply measurement equation restrictions. For more see nb_var.setMeasurementEqRestriction.';
            
        end
        
        function obj = method(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_bridge_forecast_vintages')
                obj.helpStruct.method = [...
                    'The method used to bridge the high frequency forecast to add upp to the low ',...
                    'frequency forecast. Only ''denton'' is supported for now (see nb_denton).'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.method = ...
                    'See help on the ''method'' input to the nb_model_generic.forecast method.';
            elseif strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.method = ...
                    ['Either; ''copula'', use a copula to draw consistent draws from each marginal ',...
                     'distribution (default). ''perfectcorr'', Make the assumption that the ',...
                     'aggregated variables are perfectly correlated, and we can therefore just sum',...
                     'over the distribution using the chosen weights.'];   
            elseif strcmpi(obj.nameOfPOrC,'nb_ecm') || strcmpi(obj.nameOfPOrC,'nb_ecmestimator')
                obj.helpStruct.method = ...
                    ['Either estimate the ecm model using the one step approach (''oneStep'' ) (default) or ',...
                     'estimate the model in two steps (''twoStep''). When estimating in two steps the cointegration ',...
                     'relation is estimated first, and then this is plugged into for the long run relation in the main ',...
                     'estimation. Caution: Some functionality, as conditional forecast is not supported when ''twoStep'' ',...
                     'is used (i.e. may give strange errors!).'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_convert')
                obj.helpStruct.method = ...
                    ['Method to use for converting the frequency of the forecast. See the nb_ts.convert method for ',...
                     'the supported methods.'];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
                obj.helpStruct.method = ...
                    'See the corresponding input to the nb_model_generic.forecast method.';     
            else
                obj = notDocumented(obj,'method'); 
            end
            
        end
        
        function obj = missing(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_calculate_seasonal')
                obj.helpStruct.missing = ['Allow for in-sample missing observations, and '...
                   'fill in values predicted by an estimated ARIMA process; if false, the '...
                   'seasonal adjustment will not run and a warning will be thrown. true '...
                   'or false.'];
            else
                obj.helpStruct.missing = ['Either ''zeros'' or ''interpolate''. ''zeros'' will fill '...
                    'missing observations (nans) with zeros. ''interpolate'' will fill the missing '...
                    'observations with linear interpolation.'];

                if strcmpi(obj.nameOfPOrC,'nb_calculate_factors')
                    obj.helpStruct.missing = [obj.helpStruct.missing,...
                        ' Only supported when the estim_method options is set to ''whiten''.'];
                end
            end
            
        end
        
        function obj = missingmethod(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_var') || strcmpi(obj.nameOfPOrC,'nb_pitvar')
                obj.helpStruct.missingmethod = 'Either ''forecast'', ''AR'' or ''kalmanFilter''.';
            else
                obj.helpStruct.missingmethod = 'Either ''forecast'' or ''AR''.';
            end
            
            obj.helpStruct.missingmethod = [obj.helpStruct.missingmethod, ' ''forecast'' will estimate '...
                'the model on the balanced data, then use the parameters from this estimator to '...
                'forecast the missing observation. Conditional on the other observation known at time t. '...
                'Then these forecast is used to estimate the model for the full sample. Please note that ',...
                'this method does only use the information up until time t-1, if some variable '...
                'has missing observation in time t. This option does only work for missing observation at '...
                'the end of the sample. ''AR'' will rebalance the dataset with forecasts from automatically '...
                'selected AR models. The model selection uses the Schwartz information criterion. This option '...
                'does only work for missing observation at the end of the sample.'];
            
            if strcmpi(obj.nameOfPOrC,'nb_var') || strcmpi(obj.nameOfPOrC,'nb_pitvar')
                obj.helpStruct.missingmethod = [obj.helpStruct.missingmethod,...
                    ' ''kalmanFilter'' will set up the model on state-space representation and use the Kalman ',...
                    'filter to predict the missing observations. This method support missing observation ',...
                    'anywhere in the sample.'];
            end
            
        end
        
        function obj = mixing(obj)
            obj.helpStruct.mixing = ...
                ['This options sets the mixing of the frequency of the declared dependent and/or the block exogenous variables ',...
                 'of the model. It must be set as a 1 x N*2 cellstr, where N is the number of variables that is have observations ',...
                 'on more than one frequency. One variable can max have two observed frequencies. Example; {''Var1_Q'',''Var1_M'', ',...
                 '''Var2_Q'',''Var2_M''}, means that ''Var1_Q'' is the same variable as ''Var1_M'' and ''Var2_Q'' is the same ',...
                 'variable as ''Var2_M'', but with different frequencies.'];
        end
        
        function obj = mode(obj)
            obj.helpStruct.mode = ...
                ['Either ''normal'' or ''update''. If ''update'' it will look for already found runs in the forecastOutput ',...
                 'property, and only do the once that are missing.'];
        end
        
        function obj = model(obj)
            if strcmpi(obj.nameOfPOrC,'nb_convert_forecast_vintages')
                obj.helpStruct.model = [...
                    'Sets the model that the forecast should be converted to another frequency. Either ',...
                    'as an object of class nb_model_forecast_vintages, an object of class nb_SMARTModelVariable ',...
                    'or a one line char with the path to a .mat file storing an object of class ',...
                    'nb_model_forecast_vintages'];
            elseif strcmpi(obj.nameOfPOrC,'nb_calculate_vintages')
                obj.helpStruct.model = ...
                    'The model option holds the model as an object which is of a subclass of the nb_calculate_generic class.';
            else
                obj.helpStruct.model = ...
                    'The model option holds the model as an object which is of a subclass of the nb_model_forecast class.';
            end
        end
        
        function obj = modelhigh(obj)
            obj.helpStruct.modelhigh = [...
                'Sets the model that has been producing the forecast at high frequency. Must be an object of class ',...
                'nb_model_forecast_vintages or a one line char with the full path to .mat file containing a ',...
                'nb_model_forecast_vintages object.'];
        end
        
        function obj = modellow(obj)
            obj.helpStruct.modellow = [...
                'Sets the model that has been producing the forecast at low frequency. Must be an object of class ',...
                'nb_model_forecast_vintages or a one line char with the full path to .mat file containing a ',...
                'nb_model_forecast_vintages object.'];
        end
        
        function obj = modelselection(obj)
            
            switch lower(obj.nameOfPOrC)
                case {'nb_ecm','nb_ecmestimator'}
                    meth = 'autometrics';
                case {'nb_favar','nb_fm','nb_fmdyn','nb_fmsa','nb_pitvar','nb_var','nb_tvp','nb_bvarestimator',...
                      'nb_pitestimator','nb_fmestimator','nb_mlestimator'}
                    meth = 'laglength';
                case {'nb_sa','nb_singleeq','nb_olsestimator','nb_quantileestimator','nb_stochvolestimator','nb_tslsestimator'}
                    meth = 'both';
                otherwise
                    meth = 'undoc';
            end
            
            switch meth
                case 'autometrics'
                    obj.helpStruct.modelselection = ['Setting this option to ''autometrics'' ',...
                         'will result in the model automatically selecting the lag length that is decided ',...
                         'to be the most fitting by the chose criterion. See nb_automaticModelSelection',...
                         'for more about this option.'];
                case 'laglength'
                    obj.helpStruct.modelselection = ['Setting this option to ''lagLength'' will result ',...
                        'in the model automatically selecting the lag length that is decided to be ',...
                        'the most fitting by the chosen criterion. For more see nb_lagLengthSelection.'];
                case 'undoc'
                    obj.helpStruct.modelselection = ['Sorry, the modelselection is not documented for the ',...
                                                    obj.typeName ' ' obj.nameOfPOrC '.'];
                otherwise
                    obj.helpStruct.modelselection = ['Setting this option to ''autometrics'' ',...
                         'will result in the model automatically selecting the lag length that is decided ',...
                         'to be the most fitting by the chose criterion. See nb_automaticModelSelection',...
                         'for more about this option. Setting it to ''lagLength'' will result ',...
                         'in the model automatically selecting the lag length that is decided to be ',...
                         'the most fitting by the chosen criterion. For more see nb_lagLengthSelection.'];
            end
            
            switch lower(obj.nameOfPOrC)
                case {'nb_tvp','nb_stochvolestimator'}
                    extra = ' Model selction is based on ''ols'', i.e. without time-varying parameters.';
                case {'nb_var','nb_mlestimator','nb_quantileestimator'}
                    extra = ' Model selction will allways only be based on ordinary least squares (''ols'').';
                otherwise
                    extra = '';
            end
            obj.helpStruct.modelselection = [obj.helpStruct.modelselection,extra];
            
        end
        
        function obj = modelselectionalpha(obj)
            obj.helpStruct.modelselectionalpha = ...
                ['Significance level of the arch, normality and autocorrelation test statistics ',...
                 'used for validating models during ''autometrics''. See the modelSelection option for more.'];
        end
        
        function obj = modelselectionfixed(obj)
            obj.helpStruct.modelselectionfixed = ...
                ['A logical vector indicating which regressors to keep fixed under autometrics and LagLength ',...
                 'selection. Must have same length as the inital number of exogenous variables of the model.'];
        end
        
        function obj = modelvarofinterest(obj)
            obj.helpStruct.modelvarofinterest = ...
                ['When reporting is provided the forecasted variables may not be the same as those that are ',...
                 'included in the model. This option is there to be robust to these cases.'];
        end
        
        function obj = modeltype(obj)
            obj.helpStruct.modeltype = ...
                'Sets the model type to be used. Either ''dynamic'', ''singleEq'', ''stepAhead'' or ''favar''.';
        end
        
        function obj = name(obj)
            obj.helpStruct.name = ...
                'Sets the name of the model, as a one line char.';
        end
        
        function obj = nfactors(obj)
            obj.helpStruct.nfactors = ...
                'Sets the number of factors to estimate and include in model.';
        end
        
        function obj = newdraws(obj)
            obj.helpStruct.newdraws = ...
                'See help on the ''newDraws'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = newvar(obj)
            obj.helpStruct.newvar = ...
                'A string with the name of the aggregate series.';
        end
        
        function obj = nfactorsmax(obj)
            obj.helpStruct.nfactorsmax = ...
                ['Sets the maximal number of factors to test for when using the Bai and Ng (2001) test. Default '...
                 'is the number of observables.'];
             
            if strcmpi(obj.nameOfPOrC,'nb_calculate_factors')
                obj.helpStruct.nfactorsmax = [obj.helpStruct.nfactorsmax,...
                    ' Only supported when the estim_method options is set to ''pca''.'];
            end 
        end
        
        function obj = nhor(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_judgemental_forecast')
                obj.helpStruct.nhor = ...
                    'Determines how many periods you want the fan to be spanned over. Default is four periods.';
            else
                obj.helpStruct.nhor = ...
                    ['The forecasting horizon of interest. A 1xM vector of integers. The output will ', ...
                     'be a 1xM vector of nb_model_group objects, storing the X best models at each horizon. ',...
                     'Default is 1. Caution: This options only tells at which horizon the forecasting ',...
                     'performance should be evaluated at. As different model may preform differently at ',...
                     'different horizons, the return model groups may contain different models when this ',...
                     'option is changed!'];
            end
            
        end
        
        function obj = nlags(obj)
            
            if strcmpi(obj.nameOfPOrC,'')
                obj.helpStruct.nlags = ...
                    ['Max number of lag length. If set to 4, then the loop tests all models from ',...
                     '1-4. Max is 8. For nb_var models only. '];
            elseif strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.nlags = ...
                    ['Max number autocorrelation to include in the stacked autocorrelation matrix. ',...
                     'Default is 5. If 0, only contemporaneous correlations are used. Only an option ',...
                     'when ''density'' is set to true and ''method'' is set to ''copula''. If empty the ',...
                     'full set of autocorrelations are used.'];
            else
            
                obj.helpStruct.nlags = ...
                    ['Setting nLags will set the amount of lags used in the regression. ',...
                     'Note that this will only be read if the option ''modelSelection'' is set to ''''. '];
                switch lower(obj.nameOfPOrC)
                    case {'nb_ecm','nb_ecmestimator'}
                        extra = ['Either a scalar integer, which will act on all differenced endogneous ',...
                                 'and dependent variables, a vector of integers with the same length as ',...
                                 'the ''endogneous'' option + 1 (the dependent last) or a cell array ',...
                                 'with the same length as the ''endogneous'' option + 1 (the dependent last), ',...
                                 'where each element is a scalar or vector of integers with the lag ',...
                                 'structure of each endogneous (dependent) variable.'];
                    case {'nb_fmdyn','nb_fm','nb_fmestimator'}
                        extra = ['Either as a scalar integer or a vector of integer. When given as a vector it must ',...
                                 'have the same number of elements as the number of decleared dependent variables of ',...
                                 'the model.'];
                    case {'nb_favar','nb_pitvar','nb_tvp','nb_var','nb_bvarestimator','nb_pitestimator','nb_mlestimator','nb_stochvolestimator'}
                        extra = 'As a scalar integer. ';
                    case {'nb_midas','nb_midasestimator'}
                        obj.helpStruct.nlags = '';
                        extra = ['Either a scalar integer, which will act on all exogenous variables (that are not fixed), ',...
                                 'a vector of integers with the same length as the non-fixed part of the ''exogenous'' option.'];
                    case {'nb_singleeq','nb_olsestimator','nb_quantileestimator','nb_tslsestimator'}
                        extra = ['Either a scalar integer, which will act on all exogenous variables (that are not fixed), ',...
                                 'a vector of integers with the same length as the non-fixed part of the ''exogenous'' option or ',...
                                 'a cell array with the same length as the ''exogenous'' option (''modelselectionfixed'' ',...
                                 'does not apply in this case!!), where each element is a scalar or vector of integers with ',...
                                 'the lag structure of each exogenous variable.'];
                    otherwise
                        extra = [' Sorry, the nLags option is not further documented for the ' obj.typeName ' ' obj.nameOfPOrC '.'];
                end                          
                obj.helpStruct.nlags = [obj.helpStruct.nlags,extra];
                
            end
            
        end
        
        function obj = nlagstests(obj)
            obj.helpStruct.nlagstests = ...
                'Sets the number of lags to include in the printed output of the ARCH and autocorr tests.';
        end
        
        function obj = nlagsidiosyncratic(obj)
            obj.helpStruct.nlagsidiosyncratic = ...
                'Sets the number of lags of the idiosyncratic components in the state equation. Either 0 or 1.';
        end
        
        function obj = nonstationary(obj)
            obj.helpStruct.nonstationary = ...
                ['Set it to true to allow for non-stationary dynamic factor model. In this case we need to use a ',...
                 'diffuse univariate Kalman filter during the E-step of the estimation. The initalization step ',...
                 'is in this case also changed. First the data on the observed series are differenced. The ',...
                 'factors are estimated by integrating the first nFactors principal components of this ',...
                 'transformation. Then the inital value of the loadings are based on OLS regression of the ',...
                 'observed data on these factors. The rest follow the normal steps.'];
        end
        
        function obj = nstep(obj)
            obj.helpStruct.nstep = ...
                'Sets the number of steps ahead to include in the forecasting equation. Must be a scalar integer > 0.';
            switch lower(obj.nameOfPOrC)
                case 'nb_midas'
                    extra = ' (Will lag the high frequency exogenous variables accordingly.)';
                otherwise
                    extra = '';
            end
            obj.helpStruct.nstep = [obj.helpStruct.nstep,extra];
        end
        
        function obj = nsteps(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.nsteps = ...
                    'See help on the ''nsteps'' input to the nb_model_generic.forecast method.';
            elseif strcmpi(obj.nameOfPOrC,'nb_calculate_vintages')
                obj.helpStruct.nsteps = [...
                    'The number of steps to use conditional info when the dataSource option ',...
                    'tests true on the hasConditionalInfo method. As a scalar integer. Default ',...
                    'is 1.'];
            elseif strncmpi(obj.nameOfPOrC,'nb_model_group_vintages',23)
                obj.helpStruct.nsteps = ...
                    ['The number of steps ahead forecast. The default is to take the minimum over ',...
                     'the selected models.']; 
            elseif strncmpi(obj.nameOfPOrC,'nb_manual_forecast_vintages',27)
                obj.helpStruct.nsteps = ...
                    ['The number of steps ahead forecast. The default is to take as many steps found ',...
                     'by the provided fcst source.'];       
            elseif strcmpi(obj.nameOfPOrC,'nb_convert_forecast_vintages')
                obj.helpStruct.nsteps = ...
                    ['Manually adjust the forecasting steps of the converted frequency. ',...
                     'If the model that the original forecasts come from has to short length ',...
                     'nan values are appended to satisfy the wanted forecasting steps.'];
            else
                obj.helpStruct.nsteps = ...
                    'Number of forecasting steps of all models. Default is 8.';
            end
            
        end
        
        function obj = numantsteps(obj)
            obj.helpStruct.numantsteps = ...
                'Number of anticipated steps when solving for the companion form.';
        end
        
        function obj = nvarmax(obj)
            obj.helpStruct.nvarmax = ...
                ['Max number of variables to include in one model in addition to the ''varOfInterest'' variable. ', ...
                 'Only an option when ''class'' is set to ''nb_var''.  If set to 6, the loop estimates all models ',...
                 'with 1-6 variables. Max is 8. Default is 6 or the number of variables in the data minus one.'];
        end
        
        function obj = nvarmin(obj)
            obj.helpStruct.nvarmin = ...
                ['Min number of variables to include in one model. Only an option when ''class'' is set to ''nb_var''. ', ...
                 'If set to 2, the loop estimates all models with 2-X variables. Max is ''nVarMax''. Default is 0 ',...
                 '(Also include AR models).'];
        end
        
        function obj = observables(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.observables = ...
                    'See help on the ''observables'' input to the nb_model_generic.forecast method.';
            else
                obj.helpStruct.observables = ...
                    ['A cellstr with the name(s) of the observable variable(s) of the model. E.g. ',...
                     '{''Obs1'',''Obs2''}. Information on this input will be stored in the property observables.'];
                switch lower(obj.nameOfPOrC)
                    otherwise
                        extra = '';
                end
                obj.helpStruct.observables = [obj.helpStruct.observables,extra]; 
            end
              
        end
        
        function obj = observablesfast(obj)
            
            obj.helpStruct.observablesfast = ...
                ['A cellstr with the name(s) of the fast moving observable variable(s) of the model. E.g. ',...
                 '{''ObsFast1'',''ObsFast2''}. Information on this input will be stored in the property ',...
                 'observablesFast. The variables provided here will not be used to estimate the factors, ',...
                 'but will be included in the observation equation.'];
            switch lower(obj.nameOfPOrC)
                otherwise
                    extra = '';
            end
            obj.helpStruct.observablesfast = [obj.helpStruct.observablesfast,extra];
              
        end
        
        function obj = optimal_algorithm(obj)
            obj.helpStruct.optimal_algorithm = ...
                ['One of '''' (default),''dmn'' or ''klein''. ''dmn'' uses the algorithm found in Debortoli, ',...
                 'Maih and Nunes (2010) "Loose commitment in medium-scale macroeconomic models: Theory ',...
                 'and an application", and must be used if solved with lc_commitment < 1 (default in this case). ',...
                 '''klein'' algorithm uses the nb_solab function to solve the problem. This method is restricted ',...
                 'to the cases of full commitment (and is the default in this case).'];
        end
        
        function obj = optimizer(obj)
            
            switch lower(obj.nameOfPOrC) 
                case {'nb_arima','nb_arimaestimator'}
                    obj.helpStruct.optimizer = ...
                        ['Sets the optimizer for maximum likelihood estimation. You can choose amoung the optimizers ',...
                         'return by nb_getOptimizers(''arima'').'];
                case {'nb_dsge','nb_statespaceestimator'}
                    obj.helpStruct.optimizer = ...
                        ['A string with the name of the optimizer to apply. You can choose amoung the optimizers ',...
                         'return by nb_getOptimizers(). You can also specify your own optimizer using the ',...
                         'name of that function. This function must be on the format [par,val,exitflag] = ',...
                         'funcName(fun,par,options,varargin), where fun is the function to optimize, par is the parameters ',...
                         'of the model to estimate (1 x nPar double), options is a struct with the options of the optimizer ',...
                         '(see optimset), varargin are the optional inputs given to fun. val is the value of the function at ',...
                         'the optimum, and exitflag is a flag of something going wrong (negative values must be returned in ',...
                         'this case).'];
                
                case {'nb_var','nb_mlestimator'}
                    obj.helpStruct.optimizer = ...
                        ['A string with the name of the optimizer to apply. You can choose amoung the optimizers ',...
                         'return by nb_getOptimizers(''ml''). You can also specify your own optimizer using the ',...
                         'name of that function. This function must be on the format [par,val,exitflag] = ',...
                         'funcName(fun,par,options,varargin), where fun is the function to optimize, par is the parameters ',...
                         'of the model to estimate (1 x nPar double), options is a struct with the options of the optimizer ',...
                         '(see optimset), varargin are the optional inputs given to fun. val is the value of the function at ',...
                         'the optimum, and exitflag is a flag of something going wrong (negative values must be returned in ',...
                         'this case).'];
                otherwise
                    obj.helpStruct.optimizer = ...
                        ['Sets the optimizer used by the estimator. A string with the name of the optimizer to apply. You ',...
                         'can choose amoung the optimizers return by nb_getOptimizers().'];
            end
            
        end
        
        function obj = optimset(obj)
            if strcmp(obj.nameOfPOrC,'nb_lassoEstimator')
                obj.helpStruct.optimset = ...
                    ['Sets the optimization options for estimation. See the nb_lasso.optimset or the ',...
                     'nb_getDefaultOptimset function. If [] is given, default optimization options are applied.'];
            elseif strcmp(obj.nameOfPOrC,'nb_singleEq')
                obj.helpStruct.optimset = ...
                    ['Sets the optimization options for estimation. See the nb_lasso.optimset or the ',...
                     'nb_getDefaultOptimset function. If [] is given, default optimization options are applied. ',...
                     'estim_method'' must be set to ''lasso''.'];
            else
                obj.helpStruct.optimset = ...
                    ['Set options for estimation, irf matching and optimal simple rules (nb_dsge). See the optimset or ',...
                     'the nb_getDefaultOptimset function. Which fields that are important depend on the optimizer option.'];
            end
        end
        
        function obj = onesided(obj)
            obj.helpStruct.onesided = ...
                'Set to true to run a one-sided filter.';
        end
        
        function obj = oo_(obj)
            obj.helpStruct.oo_ = ...
                'The oo_ output from dynare. Must be combined with M_ and options_.';
        end
        
        function obj = options_(obj)
            obj.helpStruct.options_ = ...
                'The options_ output from dynare. Must be combined with M_ and oo_.';
        end
        
        function obj = osr_type(obj)
            obj.helpStruct.osr_type = ...
                ['Sets if the optimal simple rules should be optimized under discretion (''discretion'') or ',...
                 'commitment (''commitment''). ''commitment'' is default.'];
        end
        
        function obj = output(obj)
            obj.helpStruct.output = ...
                'See help on the ''output'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = outvariables(obj)
            if strcmp(obj.nameOfPOrC,'nb_shorteningEstimator') || strcmp(obj.nameOfPOrC,'nb_calculate_expr')
                obj.helpStruct.outvariables = [...
                    'If the func options is used you need to supply the variable names of the resulting time-series. ',...
                    'Must be a cellstr with length M. For more see the func option.'];
            else
                obj.helpStruct.outvariables = ...
                    'A cellstr with the names of the converted variables. Must be of same length as the inVariables';
            end
        end
        
        function obj = page(obj)
            obj.helpStruct.page = ...
                ['Select the page to estimate the model on when a multi-paged dataset is given to the ''data'' property. ',...
                 'Only needed when the ''real_time_estim'' property is set to false (0).'];
        end
        
        function obj = parallel(obj)
            
            switch lower(obj.nameOfPOrC)
                case 'nb_model_selection_group'
                    obj.helpStruct.parallel = ...
                        'Run model selection in parallel. true or false. Default is false.';
                case 'nb_model_group_vintages.aggregateforecast'
                    obj.helpStruct.parallel = ...
                        'When numel(obj) > 1 you may run the process in parallel. true or false.';
                case 'nb_model_group_vintages.combineforecast'
                    obj.helpStruct.parallel = ...
                        ' Set to true to run forecast combination in parallel.';    
                otherwise
                    obj.helpStruct.parallel = ...
                        ['Give true (1), default is false (0). Run recursive estimation procedure in parallel. ',...
                         'Be aware that this not necessary apply to all estimation algorithm. Parallel Toolbox is needed. ',...
                         'If you have not open the parallel pool it will open (and close) it during the call to the estimate ',...
                         'method. If you opened up the parallel pool before calling the estimate method it will still be open.'];
            end
            
        end
        
        function obj = parameterdraws(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.parameterdraws = ...
                    'See help on the ''parameterDraws'' input to the nb_model_generic.forecast method.';
            else
                obj.helpStruct.parameterdraws = ...
                    'Number of draws of the parameters. When set to 1 it will discard parameter uncertainty. Default is 1.';
            end
        end
        
        function obj = parameters(obj)
            obj.helpStruct.parameters = ...
                ['A cellstr with the names of the parameters of the model. E.g. {''Param1'',''Param2''}. Can also be ',...
                 'supplied by a model file, see nb_nonLinearEq.parse.'];
        end
        
        function obj = path(obj)
            obj.helpStruct.path = ...
                ['Set the path for where to save down the object after update is finished. This can be ',...
                 'used to create a model library for automatic updating. Should not include the filename ',...
                 'as this is taken from the name property.'];
        end
        
        function obj = perc(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.perc = ...
                    'See help on the ''perc'' input to the nb_model_generic.forecast method.';
            else
                obj = notDocumented(obj,'perc'); 
            end
            
        end
        
        function obj = polylags(obj)
            
            obj.helpStruct.polylags = [...
                'When setting the ''algorithm'' option to ''almon'' or ''legendre'' you can set the ',...
                'number of regressors to construct from the lags. Must be a number less than the ''nLags'' + 1 ',...
                'input.'];
            
        end
        
        function obj = prior(obj)
            
            switch lower(obj.nameOfPOrC)
                case 'nb_dsge'
                    obj.helpStruct.prior = ...
                        ['A struct. Sets the prior on the parameters. See the setPrior method for more on this option ',...
                         '(you can also use obj = set(obj,''prior'',yourPrior) as with all other options).'];
                case 'nb_favar'
                    obj.helpStruct.prior = ...
                        'Not yet supported for the nb_favar class.';
                case {'nb_tvp','nb_stochvolestimator'}
                    obj.helpStruct.prior = ...
                        'A struct. Sets the prior options. See nb_tvp.priorTemplate for more on this option.';
                case {'nb_var','nb_bvarestimator'}
                    obj.helpStruct.prior = ...
                        'A struct. Sets the BVAR prior options. See nb_var.priorTemplate for more on this option.';
                otherwise
                    obj = notDocumented(obj,'prior'); 
            end
            
        end
        
        function obj = projected(obj)
            
            obj.helpStruct.projected = [...
                'You need to list the projected variables you have fetched conditional information on, but ',...
                'not used as variables in the model, but used in reporting. As a cellstr.'];
            
        end
        
        function obj = quantile(obj)
            obj.helpStruct.quantile = ...
                ['Sets the quantile to estimate when doing quantile regression. A scalar double between 0 and 1 or a vector of ',...
                 'double values between 0 and 1. 0.5 will be the median.'];
        end
        
        function obj = rcondtol(obj)
            obj.helpStruct.rcondtol = ...
                'Tolerance when using rcond(X). I.e. when testing if X is well conditioned. Defualt is eps^(3/4).';
        end
        
        function obj = real_time_estim(obj)
            obj.helpStruct.real_time_estim = ...
                'A binary input deciding whether or not the estimation is made on real-time data.';
        end
        
        function obj = recursive_estim(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
                obj.helpStruct.recursive_estim = ...
                    ['Set to true to produce recursive out-of-sample forecast, otherwise in-sample forecast are ', ...
                     'produced. I.e. whether or not recursive estimation should be done. Default is true.'];
            else
                obj.helpStruct.recursive_estim = ...
                    'A binary input deciding whether or not the estimation will be done recursively.';
            end
            
        end
        
        function obj = recursivedetrending(obj)
            obj.helpStruct.recursivedetrending = ...
                ['Give true to utilize the nb_model_recursive_detrending class when doing the model ',...
                 'selection. E.g. when you want to use the hp-filter for de-trending recursivly, and want to ',...
                 'find out how bad the end problems of the hp-filter may be.'];
        end
        
        function obj = recursive(obj)
            obj.helpStruct.recursive = ...
                ['Calculate the correlation matrix recursivly when aggregating density forecast ',...
                 'using the ''copula'' method. true or false. Default is false.'];
        end    
            
        function obj = recursive_end_date(obj)
            obj.helpStruct.recursive_end_date = ...
                ['The end date of the recursive estimation. When doing forecast, the last recursive '...
                 'forecast will be produced from this date + 1 and nSteps forwards. Can be empty. Default ',...
                 'is the end of the data.'];
        end
        
        function obj = recursive_estim_end_date(obj)
            obj.helpStruct.recursive_estim_end_date = ...
                ['End date of the recursive estimation. Default is to end when the data ends. ',...
                 'This input must be of the format dd.mm.yy, ddmmyy, yyyyMm(m)d(d), yyyyWw(w), ',...
                 'yyyyMm(m), yyyyQq(q), yyyyKk(k) or yyyy, or it may be a nb_dat object. This ',...
                 'input is only used in the case the ''recursiveDetrending'' option is set to true.'];
        end
        
        function obj = recursive_estim_start_date(obj)
            obj.helpStruct.recursive_estim_start_date = ...
                ['Start date of the recursive estimation. Default is to start when the degree\n',...
                 'of freedom allow it to start. This input must be a one line char on the format dd.mm.yy, ddmmyy, yyyyMm(m)d(d), ',...
                 'yyyyWw(w) ,yyyyMm(m), yyyyQq(q), yyyyKk(k) or yyyy, or it may be a nb_date object. The input date cannot be ',...
                 'before the ''estim_start_date'' option.'];
            if strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
               obj.helpStruct.recursive_estim_start_date = [obj.helpStruct.recursive_estim_start_date,...
                   'This means that the start date of recursive forecast will be this date plus one.'];
            end
             
        end
        
        function obj = recursive_estim_start_ind(obj)
            obj.helpStruct.recursive_estim_start_ind = ...
                'Starting period of recursive estimation. Must be less than estim_end_ind and greater than estim_start_ind.';
        end
        
        function obj = recursive_start_date(obj)
            obj.helpStruct.recursive_start_date = ...
                ['The start date of the recursive estimation (will override the recursive_estim_start_date ',...
                 'option of the object stored at the model property). When doing forecast the first recursive ',...
                 'forecast will be produced from this date + 1 and nSteps forwards. Must be provided!'];
        end
        
        function obj = reevaluate(obj)
            obj.helpStruct.reevaluate = 'Deprecated.';
        end
        
        function obj = regimedraws(obj)
            obj.helpStruct.regimedraws = ...
                'See help on the ''regimeDraws'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = removezeroregressors(obj)
            obj.helpStruct.removezeroregressors = ...
                ['Give true to automatically detect regressors that are zero for the whole estimation sample, ',...
                 'and remove those variables from the estimation. All these variables are assign a coefficent of 0 with ',...
                 'nan as standard error.'];
        end
        
        function obj = renamevariables(obj)
            obj.helpStruct.renamevariables = [...
                'Rename the calculated variables. The renaming take place in getCalculated. ',...
                'Must have same length as the number of calculated variables.'];
        end
        
        function obj = report(obj)
            obj.helpStruct.report = ...
                ['Give 0 to make it report to the command line, otherwise it will report to a ',...
                 'GUI. Default is 0.'];
        end
        
        function obj = reporting(obj)
            obj.helpStruct.reporting = ...
                'See the reporting property of the nb_model_generic class.';
        end
        
        function obj = requireddegreeoffreedom(obj)
            obj.helpStruct.requireddegreeoffreedom = ...
                ['Number of required degree of freedom when estimating a model, i.e. T - nParam > required degree ',...
                 'of freedom. T is the number of observations and nParam is the number of estimated parameters.'];
        end
        
        function obj = restrictions(obj)
            obj.helpStruct.restrictions = ...
                ['A 2 x N cell array with the estimation parameters to restrict/calibrate to a given value. First ',...
                 'row must be the name of the exogenous variables to restrict, while the second row must be the ',...
                 'values to restrict the parameter of the given exogenous variables to. Use ''constant'' and ''time_trend''',...
                 'to restrict the parameters of the contant term and the time trend respectively.'];
        end
        
        function obj = regularization(obj)
            obj.helpStruct.regularization = ...
                ['Which value to use for L1 or L2 regularization on the parameters when the model is estimated with LASSO or RIDGE ',...
                 'respectively. Default is [], i.e. the parameter is found, see nb_lasso or nb_ridge function for more on this.'];
            
        end
        
        function obj = riseobject(obj)
            obj.helpStruct.riseobject = ...
                'A RISE dsge model.';
        end
        
        function obj = rollingwindow(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.rollingwindow = ...
                    ['If the correlation matrix should be calculated recursivly with a rolling window. ',...
                     'Default is [], i.e. to use the full sample to calculate the correlation matrix.'];     
            else
                obj.helpStruct.rollingwindow = ...
                    'Length of rolling window for recursive estimation, as a scalar double.';
            end
            
        end
        
        function obj = sampler_options(obj)
            obj.helpStruct.sampler_options = ...
                ['A struct with the setting for how to sample from the posterior distribution or the ',...
                 'updated prior. The ''sampler'' field decides which function of the nb_mcmc package ',...
                 'that is called. The supported samplers are nb_mcmc.mhSampler and nb_mcmc.nutSampler. ',...
                 'See this function for help on each field of this option (they may differ).'];
        end
        
        function obj = sar(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
                obj.helpStruct.sar = ...
                    ['Set to true to test for seasonal autoregressiv terms in the arima models as well. ',...
                     'Only for monthly and quarterly data.'];
            else
                obj.helpStruct.sar = ...
                    ['Lets you manually set the degree of the seasonal autoregressiv terms in the arima estimation, ',...
                     'set to 0 if you don''t want it included (default). If quarterly data set to 4, while for monthly ',...
                     'set it to 12.'];
            end
            
        end
        
        function obj = savedraws(obj)
            obj.helpStruct.savedraws = ...
                ['Set to false to prevent saving the posterior results to file. Be aware that this prevent you from ',...
                 'drawing from the posterior distribution after estimation is done, but if you are only interested in ',...
                 'point forecast it will speed up the estimation process. Default is true.'];
        end
        
        function obj = scorehor(obj)
            obj.helpStruct.scorehor = ...
                ['Give ''mean'' to calculate the model that on average does best over all the ',...
                 'selected horizons (see nHor option).'];
        end
        
        function obj = scoretype(obj)
            obj.helpStruct.scoretype = ...
                ['A string with on of the following; ''MSE'' (Mean Squared Error), ''RMSE'' (Root Mean Squared ',...
                 'Errors). ''ESLS'' (Exponetial of the Sum of the Log Scores), ''EELS'' (Exponetial of the ',...
                 'Expected Log Scores) or ''equal'' (use equal weights).'];
        end
        
        function obj = scorer(obj)
            obj.helpStruct.scorer = ...
                'An object of a subclass of the nb_scorer class.';
        end
        
        function obj = seasonaldummy(obj)
            obj.helpStruct.seasonaldummy = ...
                ['If you want to include seasonal dummies in your regression you can give; '...
                '''centered'' or ''uncentered''. Default is not to include them, i.e. ''''. Can only be added if the ',...
                'data is on quarterly or monthly frequency.'];
        end
        
        function obj = set2nan(obj)
            obj.helpStruct.set2nan = ...
                ['Set observations to nan, so to not use these observationos during estimation of the model. See the ',...
                 'help on the nb_estimator.set2nan function for more on this input.'];
        end
        
        function obj = setrtozero(obj)
            obj.helpStruct.setrtozero = ...
                ['Set the measurement error covariance matrix to 0 during conditional forecasting, by ',...
                 'setting this option to true.'];
        end
        
        function obj = shockproperties(obj)
            obj.helpStruct.shockproperties = ...
                ['A struct with the shock properties. Used when solving for the companion form. For more ',...
                 'on this inputs see the shockProps input to the nb_model_generic.forecast method.'];
        end
        
        function obj = sigmamethod(obj)
            obj.helpStruct.sigmamethod = ...
                ['Either ''var'' or ''correlation''. If set to ''var'' the autocorrelation matrix is estimated ',...
                 'using the theoretical conditional moments of the forecast from a VAR. If ''correlation'' the ',...
                 'autocorrelation matrix is estimated based on the emprirical data only. ''correlation'' is default.'];
        end
        
        function obj = silent(obj)
            obj.helpStruct.silent = ...
                ['Set it to true if you want the methods you call to be silent, i.e. not display comments ',...
                 'in the command line. Default is false.'];
        end
        
        function obj = sma(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_selection_group')
                obj.helpStruct.sma = ...
                    ['Set to true to test for seasonal moving average terms in the arima models as well. ',...
                     'Only for monthly and quarterly data.'];
            else
                obj.helpStruct.sma = ...
                    ['Lets you manually set the degree of the seasonal moving average terms in the arima estimation, ',...
                     'set to 0 if you don''t want it included (default). If quarterly data set to 4, while for monthly ',...
                     'set it to 12.'];
            end
            
        end
        
        function obj = solve_check_stability(obj)
            obj.helpStruct.solve_check_stability = ...
                ['For more on this option see the RISE method dsge.solve. Only applies for ',...
                 'models parsed and solved with the RISE toolbox.'];
        end
        
        function obj = solve_initialization(obj)
            obj.helpStruct.solve_initialization = ...
                ['Sets how to initialize the H matrix when the model is solved under loose commitment. ',...
                 'Chose from ''last'', ''load'', ''zeros'', ''commitment'' or ''backward''. ''last'' ',...
                 'will start out with the commitment solution (using Klein''s algorithm), and then if ',...
                 'the model is resolved it will start from the last found solution. This is the default ',...
                 'option. ''load'' will try to load the file ''H0'' from the folder given by nb_userpath(''gui''), ',...
                 'if the model has not been solved since last clearing of memory. Otherwise the same as ''last''. ',...
                 '''zeros'' will start out with all elements set to zeros. ''commitment'' will use the commitment ',...
                 'solution (using Klein''s algorithm) as the initial value for H, while ''backward'' will use the ',...
                 'backward solution inv(A0)*Alag. If you have parsed and want to solve the model with RISE see ',...
                 'help on the same option in RISE (''zeros'' is default).'];
        end
        
        function obj = solve_order(obj)
            obj.helpStruct.solve_order = ...
                ['The approximation order of the solution of the model. Default is 1. Must be ',...
                 'set to a scalar integer > 0. Only when model is parsed and solved with RISE.'];
        end
        
        function obj = solver(obj)
            obj.helpStruct.solver = ...
                ['Sets the solver to use when solving for the steady-state of the model, i.e. when ',...
                 '''steady_state_solve'' is set to true (or 1). The solvers supported are the once that ',...
                 'is returned by the nb_getSolvers function. It can also be a function name or function ',...
                 'handle. In this case it must have the followinf syntax [x,fVal,exitflag] = solveFunc(',...
                 'fHandle,init,options,varargin). x is the solution, as a double vector. fVal is a scalar ',...
                 'double with the function value at solution. exitflag must be a scalar integer with the ',...
                 'reason of exiting. Negative values must be returned in the case the solver fails. fHandle ',...
                 'is the multivariate function to solve. init is the inital guess, as a nVar x 1 double. ',...
                 'options is a struct with the options of the solver. varargin is the optional inputs that are ',...
                 'given to the fHandle function.'];
        end
        
        function obj = stabilitytest(obj)
            
            switch lower(obj.nameOfPOrC) 
                case {'nb_arima','nb_model_selection_group','nb_var'}
                    default = 'true';
                otherwise
                    default = 'false';
            end
            obj.helpStruct.stabilitytest = ...
                ['true or false. If true, stability is forced on the model(s) during estimation. ',...
                 'Default is ' default '.'];
            if strcmpi(obj.nameOfPOrC,'nb_var')
                obj.helpStruct.stabilitytest = [obj.helpStruct.stabilitytest, ...
                    ' Only an option when model is estimated using an algorithm using the Kalman filter. I.e. when ',...
                    'dealing with missing observation or mixed frequency data.'];
            end
            
        end
        
        function obj = startdate(obj)
        
            obj.helpStruct.startdate = ...
                ['Start date of the aggregation of forecast. Default is to use the first shared run date. Must ',...
                 'be given as a string that can be given to the nb_day constructor or a nb_day object.'];
            
        end    
            
        function obj = startingprob(obj)
            obj.helpStruct.startingprob = ...
                'See help on the ''startingProb'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = startingvalues(obj)
            obj.helpStruct.startingvalues = ...
                'See help on the ''startingValues'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = states(obj)
            obj.helpStruct.states = ...
                'See help on the ''states'' input to the nb_model_generic.forecast method.';
        end
        
        function obj = stdreplic(obj)
            obj.helpStruct.stdreplic = ...
                'Sets the number of replication to use when the std is bootstrapped.';
        end
        
        function obj = stdtype(obj)
            
            switch lower(obj.nameOfPOrC)
                case {'nb_favar','nb_fm','nb_fmdyn','nb_fmsa'}
                   obj.helpStruct.stdtype = ...
                        ['Sets the type of standard errors to be calculated. Either ''h'' ',...
                         '(homoskedasticity only), ''w'' (White heteroskedasticity robust), ''nw'' (Newey-West ',...
                         'heteroskedasticity and autocorrelation robust) or the bootstrap method to be used to '...
                         'calculate the standard errors of regression. See for example the description of the ''method'' ',...
                         'input to the nb_model_generic.irf method (only the bootstrap methods are supported). Only ',...
                         'in the case that a bootstrap method is chosen the factors loadings (stored as lambda in the ',...
                         'results property) will report stds. (See stdLambda of the results property). '];
                case 'nb_midas'
                    obj.helpStruct.stdtype = ...
                        ['Sets the type of standard errors to be calculated. Either ''h'' (homoskedasticity only), ''w'' ',...
                         '(White heteroskedasticity robust) or ''nw'' (Newey-West heteroskedasticity and autocorrelation ',...
                         'robust). Only an option if the algorithm option is set to ''unrestricted'', otherwise the fischer ',...
                         'information is used.'];
                case 'nb_singleeq'
                    obj.helpStruct.stdtype = ...
                        ['Sets the type of standard errors to be calculated. Either ''h'' (homoskedasticity only), ''w'' (White ',...
                         'heteroskedasticity robust) or ''nw'' (Newey-West heteroskedasticity and autocorrelation robust). For ',...
                         'quantile regression these options will be converted to ''sparsity''. See nb_qreg for more on the ',...
                         'sparsity method.'];
                otherwise
                    obj.helpStruct.stdtype = ...
                        ['Sets the type of standard errors to be calculated. Either ''h'' ',...
                        '(homoskedasticity only), ''w'' (White heteroskedasticity robust) or ''nw'' (Newey-West ',...
                        'heteroskedasticity and autocorrelation robust). (Only applies for the estimation method ''ols''.)'];
            end
            
        end
        
        function obj = steady_state_block(obj)
            obj.helpStruct.steady_state_block = ...
                ['Either 1 (true) to do block decompose the model before solving the steady-state, ',...
                 'or 0 (false) to not. Default is not. For more on this options see Mihoubi (2011), ',...
                 '"Solving and estimating stochastic models with block decomposition" section 2. ',...
                 'Only an option for models parsed and solved with the NB toolbox.'];
        end
        
        function obj = steady_state_change(obj)
            obj.helpStruct.steady_state_change = ...
                ['A N x 2 cellstr. The first column must be the parameters that is changed to ',...
                 'being a endogenous variable when solving for the steady-state, while the second column must ',...
                 'be the endogenous variable that is being switch to a parameter. The values of the endogenous ',...
                 'variable will be the values given by th initial values. for more on how to set the initial ',...
                 'values see the ''steady_state_solve'' option. Only an option for models parsed and solved with ',...
                 'the NB toolbox.'];
        end
        
        function obj = steady_state_default(obj)
            obj.helpStruct.steady_state_default = ...
                ['A function handle. This option sets how to assign starting value of all the variables ',...
                 'that have not been assign a starting value with the use of ''steady_state_file''',...
                 ' or ''steady_state_init'' options. Default is @zeros.'];
        end
        
        function obj = steady_state_debug(obj)
            obj.helpStruct.steady_state_debug = ...
                ['Give true to dump the steady-state solution to the workspace in case of an error ',...
                'during numerical solving of the steady state.'];
        end
        
        function obj = steady_state_exo(obj)
            obj.helpStruct.steady_state_exo = ...
                ['A struct where the fieldnames are the innovations that are permanently changed and ',...
                 'fields are the values of the innovation. E.g. struct(''e'',0.01). See also getEndVal ',...
                 'and perfectForesight methods. Only for models parsed and solved with NB toolbox.'];
        end
        
        function obj = steady_state_file(obj)
            obj.helpStruct.steady_state_file = ...
                ['A function handle or a string with the name (without extension) of the function ',...
                'that solves the steady-state. If no file is provided it is assumed that the steady ',...
                'state is zero (Except in the case that the model is parsed and solved with Dynare). ',...
                'See examples on how to write the steady-state file here; \\NBTOOLBOX\Econometrics\test\DSGE\FRWZ'];
        end
        
        function obj = steady_state_fixed(obj)
            obj.helpStruct.steady_state_fixed = ...
                ['Sets the fixed values for the numerical steady-state solver. Must be struct with ',...
                 'the names of the endogenous variable as fieldnames and the fields as the fixed values ',...
                 'or a N x 2 cell with the variable names in the first column and the fixed value in the ',...
                 'second. To use the the value returned by the ''steady_state_file'' option or set by the ',...
                 '''steady_state_init'' option set the value of this option to nan. ',...
                 'Can also be used if the ''steady_state_file'' option is used. In this case it can be used ',...
                 'to set steady-state values of variable not provided by the file. In the case that this input ',...
                 'give steady-state values for variables already solved for by the file, the values from the ',...
                 'file is used! Only for models parsed and solved with NB toolbox.'];
        end
        
        function obj = steady_state_imposed(obj)
            obj.helpStruct.steady_state_imposed = ...
                ['Set to true if you impose the steady-state. If not (default) the value ',...
                 'from the steady-state file is taken as initial values for the numerical ',...
                 'solver. Only for models parsed and solved with RISE.'];
        end
        
        function obj = steady_state_init(obj)
            obj.helpStruct.steady_state_init = ...
                ['Sets the inital values for the numerical steady-state solver. Must be struct with ',...
                 'the names of the endogenous variable as fieldnames and the fields as the inital ',...
                 'values or a N x 2 cell with the variable names in the first column and the value in ',...
                 'the second. Variables not assign here will get 0 as its inital value. Only when model ',...
                 'is parsed and solved with NB toolbox.'];
        end
        
        function obj = steady_state_optimset(obj)
            obj.helpStruct.steady_state_optimset = ...
                ['Set options for steady-state solving. See the optimset or the nb_getDefaultOptimset ',...
                 'function. Which fields that are important depend on the ''solver'' option.'];
        end
        
        function obj = steady_state_solve(obj)
            obj.helpStruct.steady_state_solve = ...
                ['Set to true if the steady-state is going to saved numerically. Use either the ',...
                 '''steady_state_file'' option or the ''steady_state_init'' option to set the ',...
                 'starting values of the numerical solver. Only when model is parsed and solved with ',...
                 'NB toolbox.'];
        end
        
        function obj = steady_state_tol(obj)
            obj.helpStruct.steady_state_tol = ...
                ['Sets the tolerance value when checking the steady-state, i.e. if the rhs-lhs > steady_state_tol ',...
                 'an error will be given in checkSteadyState. Only an option for models parsed and solved with ',...
                 'the NB Toolbox.'];
        end
        
        function obj = steady_state_unique(obj)
            obj.helpStruct.steady_state_unique = ...
                ['Set to true if the steady-state is the same over all regimes. Only applies ',...
                 'for model parsed and solved with RISE.'];
        end
        
        function obj = stochastictrend(obj)
            obj.helpStruct.stochastictrend = ...
                ['Set to true to update the steady state given trends in the observation block. ',...
                 'Default is false. See also the ''stochasticTrendInit'' option.'];
        end
        
        function obj = stochastictrendinit(obj)
            obj.helpStruct.stochastictrendinit = ...
                ['Set the inital condition for the trends of the observation block. See the help ',...
                 'of the method assignInitVal for more on this option. Default is a value of 0 for ',...
                 'variables of the observation block.'];
        end
        
        function obj = store2(obj)
            if strcmpi(obj.nameOfPOrC,'nb_calculate_vintages') 
                 obj.helpStruct.store2 = ...
                    ['Set the database to store the calculated series to. Must be set to an object which ',...
                     'is of a subclass of the nb_store2Database class. Use the nb_store2Database.getSubClasses() ',...
                     'method to get the available subclasses.'];
            else
                obj.helpStruct.store2 = ...
                    ['Set the database to store the forecasts to. Must be set to an object which is of a ',...
                     'subclass of the nb_writeFcst2Database class. Use the nb_writeFcst2Database.getSubClasses() ',...
                     'method to get the available subclasses.'];
            end
        end
        
        function obj = subcomparetorev(obj)
            obj.helpStruct.subcomparetorev = ...
                ['Which revision to compare the forecast to for the models to combine. It will re-evaluate ',...
                 'the models to combine if the compareToRev of the individual model is not equal to this option. ',...
                 'Default is first release, i.e. 1. Give 5 to get fifth release. Must be an ',...
                 'integer. 0 means you compare to the final vintage, instead of any release series.'];
        end
        
        function obj = systemprior(obj)
            obj.helpStruct.systemprior = ...
                ['Sets the priors on the system, such as moments, irf, etc. You have two choices. ',...
                 'The first is to assign this option (using the set method) a function_handle. The function_handle ',...
                 'must take two inputs. The parser property and the solution property (simple version). In this ',...
                 'way you can calculate all system properties of the model before you evaluate your priors on ',...
                 'those moments. The function_handle must return the log system prior density (as a scalar double). ',...
                 'The second option is to use the setSystemPrior method to apply standardized system priors (i.e. ',...
                 'this method makes the function for you!). The approach used can be found in Andrle and Benes ',...
                 '(2013), "System Priors: Formulating Priors about DSGE Models'' Properties". Only for models ',...
                 'parsed and solved with NB toolbox.'];
        end
        
        function obj = takestartfcstfromdb(obj)
            obj.helpStruct.takestartfcstfromdb = ['If the database you fetch the forecast from (the fcstDB options), ',...
                'both include history and fcst, you need to set this to true. In this case the start date of the ',...
                'forecast is taken from the end date of the matching context from the dataSource options plus 1.'];
        end
        
        function obj = tempparametersverbose(obj)
            obj.helpStruct.tempparametersverbose = ['Print equations after the parsing of temporary parameters ',...
                'declared with #.'];
        end
        
        function obj = time_trend(obj)
            obj.helpStruct.time_trend = ['A binary input deciding whether or not to include a time trend in the ',...
                 'estimation. Default is false.'];
        end
        
        function obj = timevarying(obj)
            obj.helpStruct.timevarying = ...
                ['Make some parameters time-varying. As a cellstr array with parameter names. ',...
                 'The time-varying parameters must be found as seperate time-series in the ',...
                 'options.data object. Caution : If the parameters time-series are shorter than ',...
                 'the filtered sample, the paramters are extrapolated with the end points.'];
        end
        
        function obj = tolerance(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_calculate_seasonal') || strcmpi(obj.nameOfPOrC,'nb_seasonalEstimator')
                obj.helpStruct.tolerance = 'Sets the tolerance level of the seasonal adjustment algorithm. Default is 1e-5.';
            else
                obj = notDocumented(obj,'tolerance'); 
            end
            
        end
        
        function obj = transformation(obj)
            obj.helpStruct.transformation = ...
                ['Apply a given transformation to the observables before estimating the model. ''standardize'' ',...
                 'will standardise the data , while ''none'' (default) will not transform the data. The ',...
                 'transformation will be applied after separating out the contribution of the exogenous variables.'];
        end
        
        function obj = transformations(obj)
            obj.helpStruct.transformations = ...
                'See the transformations input to the nb_ts.createVariables method.';
        end
        
        function obj = transition(obj)
            obj.helpStruct.transition = [...
                'A logical vector with same length as the exogenous variables of the ARIMA model. Set ',...
                'an element to true to include the corresponding exogenous variable in the transition equation ',...
                'instead of the observation equation. Default is [], i.e. include all exogenous variables in the ',...
                'observation equation. Caution: The constant term is always included in the observation equation.'];
        end
        
        function obj = type(obj)
            obj.helpStruct.type = ...
                'The type of output from the filter. Either ''gap'' or ''trend''.';
        end
        
        function obj = typedoc(obj)
            obj.helpStruct.typedoc = ...
                'The type of distribution you want to base the fan on. Default is the normal distribution.';
        end
        
        function obj = ub(obj)
            obj.helpStruct.ub = ...
                ['The ub option sets the upper bound on the parameters during estimation (optimization). A struct, where ',...
                 'the parameter names must be the fieldnames and the upper bound of those are the fields. The parameters that are ',...
                 'not set gets the upper bound of inf.'];
        end
        
        function obj = uncertain_draws(obj)
            obj.helpStruct.uncertain_draws = ...
                ['The number of draws to make when parameter uncertainty is taken into account ',...
                 'in the different solution methods. Default is 500. See also; nb_dsge.optimalSimpleRules.'];
        end
        
        function obj = updateall(obj)
            obj.helpStruct.updateall = ...
                ['Set to true to only fetch data for all model as it was one, i.e. apply if all models share same data source. ',...
                 'Useful for model selection purposes, otherwise this options will not work. This options is set to false after ',...
                 'first call to the updateData method.'];
        end
        
        function obj = updateateachcontext(obj)
            obj.helpStruct.updateateachcontext = ...
                ['Set to true to only fetch one context at the time when updating the forecasts of the object at new contexts. ',...
                 'Default is to fetch all contexts and then update the forecasts at all of these contexts.'];
        end
        
        function obj = unbalanced(obj)
            if strcmpi(obj.nameOfPOrC,'nb_sa') || strcmpi(obj.nameOfPOrC,'nb_midas') || strcmpi(obj.nameOfPOrC,'nb_olsEstimator') ...
                    || strcmpi(obj.nameOfPOrC,'nb_midasEstimator')
                obj.helpStruct.unbalanced = ...
                    ['This will also take into account ragged edge problem for the regressors of the model, ',...
                     'i.e. automatically adjust the lag/lead structure of the exogenous regressors to the information ',...
                     'set.'];
            else
                obj.helpStruct.unbalanced = ...
                    ['Set to true to handle unbalanced dataset in the estimation of the factors. See the nb_pca function for more. ',...
                     'Default is false. This will also take into account ragged edge problem for factor models. ',...
                     'i.e. automatically adjust the lag structure of the factors to the information set.'];
                if strcmpi(obj.nameOfPOrC,'nb_calculate_factors')
                    obj.helpStruct.unbalanced = [obj.helpStruct.unbalanced,...
                        ' Only supported when the estim_method options is set to ''pca''.'];
                end 
                 
            end
        end
        
        function obj = var2merge(obj)
            obj.helpStruct.var2merge = ...
                ['Give the name of the variable to merge history and forecast of. The variable must be contain in the ',...
                 'dataSource or be an output from using the transformation option on the dataSource, and it must be ',...
                 'contained in fcstDB or be an output from using the forecastTransformation option on the fcstDB. This ',...
                 'is the only variable that can be used in reporting that has forecast!'];
        end
        
        function obj = variables(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.variables = ...
                    ['A cellstr with same length as obj.models. These are the variables from the different models to ',...
                     'aggregate. Default is to take the first variable of each model from the forecastOutput property.'];
            else
                obj.helpStruct.variables = ...
                    ['When ''class'' is set to ''nb_var''; The variables to use to create set of models. ', ...
                     'When ''class'' is set to ''nb_arima''; The exogenous variables to test for. These exogenous ',...
                     'variables are forecast with their own individual AR(p) models. Variables constructed with ',...
                     'the ''transformations'' input may be used.'];
            end
            
        end
        
        function obj = varname(obj)
            obj.helpStruct.varname = ...
                ['If lochist is set to a database (.db) you need to provide the variable to fetch with this option. ',...
                 'Default is empty.'];
        end
        
        function obj = varofinterest(obj)
            
            if strcmpi(obj.nameOfPOrC,'nb_model_vintages')
                obj.helpStruct.varofinterest = ...
                    ['Must be set to a cellstr, and must include the variables to store the forecast of. The model ',...
                     'must produce forecast of the selected variables. They cannot include exogenous variables of ',...
                     'the model!'];
            elseif strcmpi(obj.nameOfPOrC,'nb_bridge_forecast_vintages')
                obj.helpStruct.varofinterest = ...
                    ['Must be set to a cellstr, and must include the variables to store the forecast of. The model ',...
                     'must produce forecast of the selected variables.'];
            elseif any(strcmpi(obj.nameOfPOrC,{'nb_calculate_vintages','nb_manual_forecast_vintages'}))
                obj.helpStruct.varofinterest = ...
                    'Select the variables that are to be stored for writing to the selected database.';    
            else
                obj.helpStruct.varofinterest = ...
                    ['As a string with the name of the variable of interest, i.e. the variable that is being the base ',...
                     'for the forecast evaluation while selecting the best models.']; 
            end
            
        end
        
        function obj = waitbar(obj)
            if strcmpi(obj.nameOfPOrC,'nb_model_group_vintages.aggregateForecast')
                obj.helpStruct.waitbar = ...
                    'Give true for including waitbar when looping a set of objects, otherwise false. Default is true.';
            else
                obj.helpStruct.waitbar = ...
                    'Give 1 (true) for including waitbar during estimation (if any), otherwise 0 (false). Default is 1.';
            end
        end
        
        function obj = weights(obj)
            obj.helpStruct.weights = ...
                ['The aggregation weights. As a 1 x nModels double, or a nb_modelDataSource object (time-varying ',...
                 'weights). Default is equal weights.'];
        end
        
        function obj = weightsorder(obj)
            obj.helpStruct.weightsorder = ...
                ['The order of the variable used as weights. As a 1 x nModels cellstr. The variables must be returned ',...
                 'by the weights option. Must be provided in the case that the weights option is given as a ',...
                 'nb_modelDataSource object, otherwise not in use.'];
        end
        
        function obj = weightsmethod(obj)
            obj.helpStruct.weightsmethod = ...
                ['Either ''end'', ''ar'' or ''var''. This options sets the way weights are recursivly extrapolated ',...
                 'when the ''weights'' is set ot an object of class nb_modelDataSource. See the ''method'' input to ',...
                 'the recursiveExtrapolate method of the nb_ts class for more on this option.'];
        end
        
        function obj = writeresults(obj)
            obj.helpStruct.writeresults = ...
                ['Set to true to write results to database. The store2 option must be set to an object which is ',...
                 'of a subclass of the nb_writeResults2Database class. Use nb_writeResults2Database.getWriteResultsSubClasses ',...
                 'to get a list of these subclasses.'];
        end
        
        %==================================================================
        
        function obj = notDocumented(obj,option) 
            obj.helpStruct.(lower(option)) = ['No help found for the option ''' option, ''' of the ' obj.typeName ' ' obj.nameOfPOrC '.']; 
        end
        
    end
    
end

