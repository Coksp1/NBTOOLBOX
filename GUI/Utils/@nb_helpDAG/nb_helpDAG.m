classdef nb_helpDAG < nb_writeHelp
% Description:
%
% A class for writing the help that's available through UIContextMenus 
% in DAG.
%
% Constructor:
%
%   obj = nb_helpDAG(name,option)
% 
%   Input:
%
%   - name   : A 1 x n char with the model name.
%
%   - option : A 1 x n cellstring with the options you need help on. 
% 
%   Output:
% 
%   - An nb_helpWindow with helpful comments.
% 
%   Examples:
%
%   nb_helpDAG('nb_varGUI',{'Automatic_Model_Selection'});
% 
% Written by Per Bjarne Bye 
    
% Copyright (c) 2021, Kenneth Sæterhagen Paulsen

    methods 
        
        % Constructor
        function obj = nb_helpDAG(name,option)
            
            if nargin == 0
                return
            end
            obj.name     = strrep(name,'GUI','');
            obj.option   = option;
            templateFunc = str2func([obj.name '.template']); 
            obj.options  = fieldnames(templateFunc());
            
        end
        
    
        function helpText = help(obj)
        % Syntax:
        %
        % helpText = help(obj)
        %
        % Description:
        %
        % Get the help given the property values of the object.
        %
        % Input:
        %
        % - obj : An object of class nb_helpDAG.
        %
        % Output:
        %
        % - A nb_helpWindow with helpful comments.
        %
        % Written by Per Bjarne Bye
           
            helpText = cell(1,2*length(obj.option));
            
            for ii = 1:length(obj.option)
                strOpt    = char(obj.option{ii});
                helpFuncH = str2func(strOpt);
                obj       = helpFuncH(obj);
                temp      = nb_wrapped(obj.helpStruct.(strOpt),obj.max);
                tempcat   = strcat(temp,'\n');
                tempT     = tempcat';
                tempch    = sprintf([tempT{:}]);
                
                if contains(obj.option{ii},'_')
                    title = obj.option{ii};
                    title = strrep(title,'_',' ');
                else
                    title = obj.option{ii};
                end
                helpText{ii*2-1} = title;
                helpText(ii*2)   = cellstr(tempch); 
            end

        end
        
    end

    methods(Static=true)
        
        function callback(uiHandle,~)
            
            name     = get(uiHandle,'tag');
            userData = get(uiHandle,'userData');
            helper   = nb_helpDAG(name,userData);
            helper   = set(helper,'max',85);
            helper   = set(helper,'option',userData);
            helpText = help(helper);
                
            nb_helpWindow(helpText) 
        end
        
    end
    
    %¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
    %============================ Help Text ==============================
    %¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
    
    methods(Access=protected)
        
        function obj = AR(obj)
           obj.helpStruct.AR = ...
               ['Sets the number of autoregressive terms to include in the estimation. If empty this ',...
               'number will be selected based on the chosen information criterion. ',...
               'Cannot be empty if you want to do recursive estimation. Must be a whole number ',...
               'with a maximum of 12.'];
        end
        
        function obj = ARIMA_Criterion(obj)
            obj.helpStruct.ARIMA_Criterion = ...
                ['Select the selection criterion to use to choose the best model. Used when ',...
                'AR or/and MA fields is/are empty. See the section on "Information criterion" ',...
                'in the DAG documentation for details on the criterions to choose from.'];
        end  
        
        function obj = Automatic_Model_Selection(obj)
            
            switch obj.name
                
                % autometrics
                case {'nb_ecm','nb_singleEq'}
                    obj.helpStruct.Automatic_Model_Selection = ...
                        ['Tick on to make DAG choose the appropriate number of lags to ',...
                        'include in the model. ',...
                        'There are a variety of tests used to determine the appropriate number of lags. ',...
                        'See the papers 1) Sucarrat, G. and Escribano, A. (2011): Automated Model Selection in Finance: ',...
                        'General-to-Specific Modelling of the Mean and Volatility Specifications. ',...
                        '2) Hendry, D. F. and Krolzig, H.-M. (2005): The Properties of Automatic Gets Modeling. ',...
                        'Economic Journal 115, C32 to C61. 3) Hendry, D. F. and Krolzig, H.-M. (2001): Automatic ',...
                        'Econometric Model Selection using PcGets. London: Timberlake Consultants Press ',...
                        'for detailed instructions on how the selection is done.'];
                    
                % laglength
                case {'nb_favar','nb_var'}
                    obj.helpStruct.Automatic_Model_Selection = ...
                        ['Tick on to make DAG to choose the appropriate number of lags to include ',...
                        'in the model. The decision is based on the selected information criterion. Default ',...
                        'is Akaike.'];

                otherwise
                    warning('Automatic model selection is not supported.');
            end
            
        end
        
        function obj = Burn(obj)
            obj.helpStruct.Burn = ...
                ['The number of periods to burn at the start of the simulated series. Please note that ',...
                '"Periods" refer to the number of periods after the burned sample. Only an option when ',...
                '"Type" is set to simulated.'];
        end
        
        function obj = Choose_IRF_Variable(obj)
            obj.helpStruct.Choose_IRF_Variable = ...
                'Choose the variable that should be normalized.';
        end        
      
        function obj = Constant(obj)
            obj.helpStruct.Constant = ...
                ['A binary option that decides whether or not there will be a constant term in the model. ',...
                 'If a constant term is added, it will be the first variable on the right hand side. ',...
                 'tick on to include a constant.'];
        end
        
        function obj = Continue_IRFs(obj)
            obj.helpStruct.Continue_IRFs = ...
                ['If you have paused the calculations of the IRFs you can tick this radio button to start ',...
                'from the point you paused at.'];
        end        
        
        function obj = Cov_Repair(obj)
            obj.helpStruct.Cov_Repair = ...
                ['Select if the covariance matrix of the maximum likelihood estimation is not positive definite. ',...
                'This option will try to make it so.'];
        end        
        
        function obj = Critical_Value_Model_Selection(obj)
            obj.helpStruct.Critical_Value_Model_Selection = ...
                ['Sets the critical value to be used for the econometric tests to determine the number of lags ',...
                 'to include.'];
        end
        
        function obj = Density(obj)
            obj.helpStruct.Density = ...
                'Tick to take parameter uncertainty into account.';
        end
        
        function obj = Density_FEVD(obj)
            arrow = char(hex2dec('2192'));
            obj.helpStruct.Density_FEVD = ...
                ['Tick to produce density FEVD. The output will instead be a graph with a subplot for each ',...
                'contribution of a shock to a certain variable, with the wanted percentiles around the FEVD ',...
                'of the closest to median model or median. To get the data of the closest to median model or ',...
                'median use Graph ',arrow,' Spreadsheet, and use Graph ',arrow,' Spreadsheet Fan Data to get the percentiles.'];                
        end         
        
        function obj = Density_Forecast(obj)
            obj.helpStruct.Density_Forecast = ...
                ['Select to create a density forecast. If the model is Bayesian, the density forecast will be created ',...
                'by drawing from the posterior distribution. Otherwise, the forecast will be created using ',...
                'bootstrapping. For more information about the procedure, please see the DAG documentation.'];                
        end 
        
        function obj = Density_IRFs(obj)
            obj.helpStruct.Density_IRFs = ...
                'Select to make density impulse response functions.';                
        end        
        
        function obj = Density_Method(obj)
            obj.helpStruct.Density_Method = ...
                ['The method used to produce the density forecast. This will depend on the model and estimation ',...
                'technique. In general, "Wild bootstrap" is used when the errors are heteroscedastic. "Block bootrap" ',...
                'is used when errors are autocorrelated. For a thorough explanation of the different bootstrapping ',...
                'routines, see the section "Bootstrapping" in the DAG documentation.'];                
        end
        
        function obj = Density_SD(obj)
            obj.helpStruct.Density_SD = ...
                ['Tick to produce density shock decomposition. It is not possible to get the distribution ',...
                'of the contributions of each shock at the moment, but you need to use this option for ',...
                'under-identified models. The reported results are the shock decomposition of the model ',...
                'that is closest to median (using an absolute deviation metric).'];
        end        
        
        function obj = Draws(obj)
            obj.helpStruct.Draws = ...
                'Number of residual draws. Only an option when "Type" is set to simulated.';
        end 
        
        function obj = Draws_FEVD(obj)
            obj.helpStruct.Draws_FEVD = ...
                ['The number of parameter draws to base the closest to median model or median calculation on. ',...
                'Will not work for the "Identification Draws" method.'];
        end        
        
        function obj = Draws_IRFs(obj)
            obj.helpStruct.Draws_IRFs = ...
                ['The number of parameter draws to base the calculation of the density IRFs. Will not work ',...
                'for the "Identification Draws" method.'];
        end 
        
        function obj = Draws_SD(obj)
            obj.helpStruct.Draws_SD = ...
                ['The number of parameter draws to base the closest to median model calculation on. ',...
                'Will not work for the "Identification Draws" method.'];
        end
        
        function obj = Empirical(obj)
            obj.helpStruct.Empirical = ...
                ['Tick this box to compare the moment(s) generated by the model to the corresponding empirically ',...
                'calculated moment(s).'];
        end        
        
        function obj = End_of_Forecast(obj)
            obj.helpStruct.End_of_Forecast = ...
                ['End date of the forecast. If the option "Forecast evaluation" is set to None, this option ',...
                'will do nothing. When the Forecast evaluation is set to something else the "End date" option ',...
                'will be the end date of the recursive in sample forecast evaluation. If recursive estimation ',...
                'is done it will instead set the recursive out of sample forecast end date.'];
        end        
        
        function obj = Estimation_Sample(obj)
            obj.helpStruct.Estimation_Sample = ...
                ['This option sets the observations that will be included in the estimation. ',...
                 'You will get the possible options for the estimation start date and the estimation ',...
                 'end date in the left and right drop-down menu, respectively. The end date should not ',...
                 'be set if you want the model group to be updateable. The interval is closed meaning that ',...
                 'the observations specified are included in the sample.'];
        end
        
        function obj = Exogenous_Projection(obj)
            obj.helpStruct.Exogenous_Projection = ...
                ['Use this option if you want to project the exogenous variable with the selected algorithm. ',...
                'For now you can project the exogenous variables using univariate AR processes, where the ',...
                'exogenous variables are assumed to be stationary.'];
        end        

        function obj = Graph_Output(obj)
            obj.helpStruct.Graph_Output = ...
                ['The option "Default" will produce a graph with the point or the density forecast of ',...
                'each variable including its historical values. When doing recursive forecast, only the ',...
                'forecast from the last period will be graphed. The hairyplot option will plot the actual ',...
                'data series with the recursive (point) forecasts.'];
        end        
        
        function obj = Information_Criterion(obj)
            obj.helpStruct.Information_Criterion = ...
                ['Select the information criterion you deem best suited to make DAG automatically choose the ',...
                 '"correct" number of lags. For a description of the different criterions with formulas, see ',...
                 'the section "Information criterion" in the DAG documentation.'];
        end
        
        function obj = Integration(obj)
            obj.helpStruct.Integration = ...
                ['Sets the level of integration of the series. If NaN or empty this number will be ',...
                'selected based on the augmented Dickey-Fuller test. Cannot be empty if you want to ',...
                'do recursive estimation.'];
        end
        
        function obj = Level_Method(obj)
            triang = char(hex2dec('25B8'));
            obj.helpStruct.Level_Method = ...
                ['Sets the method used to construct the level variables. One of the methods:           ',...
                triang, ' Cumulative Product: cumprod(1 + irf)                                               ',...
                triang, ' Cumulative Sum: cumsum(irf)                                                       ',...
                triang, ' Cumulative Product (log): log(cumprod(1 + irf))                                   ',...
                triang, ' Cumulative Sum (exponential): exp(cumsum(irf))                                    ',...
                triang, ' Cumulative Product (%%): cumprod(1 + irf=100)                                     ',...
                triang, ' Cumulative Sum (%%): cumsum(irf=100)                                              ',...
                triang, ' Cumulative Product (log)(%%): log(cumprod(1 + irf=100))                           ',...
                triang, ' Cumulative Sum (exponential)(%%): exp(cumsum(irf=100))                            ',...
                triang, ' 4 period growth (log approx): Moving sum over 4 periods.'];
        end 
        
        function obj = MA(obj)
           obj.helpStruct.MA = ...
               ['Sets the number of moving average terms to include in the estimation. If empty this ',...
               'number will be selected based on the chosen information criterion. ',...
               'Cannot be empty if you want to do recursive estimation. Must be a whole number ',...
               'with a maximum of 5.'];        
        end
        
        function obj = Max_AR(obj)
           obj.helpStruct.Max_AR = ...
               ['Sets the maximum number of autoregressive terms that is tested for. Only used when the AR field ',...
               'is empty. The maximal number of AR terms allowed are 12 to prevent too many ',...
               'possible models to estimate and choose from.'];        
        end
        
       function obj = Max_MA(obj)
           obj.helpStruct.Max_MA = ...
               ['Sets the maximum number of moving average terms that is tested for. Only used when the MA field ',...
               'is empty. The maximal number of MA terms allowed are 5 to prevent too many ',...
               'possible models to estimate and choose from.'];        
       end
       
       function obj = Method(obj)
           obj.helpStruct.Method = ...
               ['The method used to sample from the parameter distribution. This will depend on the model and ',...
               'estimation technique. See the section on "Bootstrapping" in the DAG documentation for the ',...
               'different bootstrap options. For bayesian models it is only possible to choose "Posterior".'];         
       end
       
       function obj = Method_FEVD(obj)
           obj.helpStruct.Method_FEVD = ...
               ['The method used to produce density FEVD. This will depend on the model and estimation ',...
               'technique. See the section "Bootstrapping" in the DAG documentation for details on the ',...
               'different bootstrap options. For bayesian models it is only possible to choose "Posterior". ',...
               'The "Identification Draws" option may be available for both types of models, if you are ',...
               'dealing with an under-identified model, and the draws have been done at the identification stage. ',...
               '(you need to do more than 100 draws to be able to use this option).'];                
       end       
       
       function obj = Method_IRFs(obj)
           obj.helpStruct.Method_IRFs = ...
               ['The method used to produce the density IRFs. This will depend on the model and estimation ',...
               'technique. See the section "Bootstrapping" in the DAG documentation for details on the ',...
               'different bootstrap options. For bayesian models it is only possible to choose "Posterior". ',...
               'The "Identification Draws" option may be available for both types of models, if you are ',...
               'dealing with an under-identified model, and the draws have been done at the identification stage. ',...
               '(you need to do more than 100 draws to be able to use this option).'];                
       end
       
       function obj = Method_SD(obj)
           obj.helpStruct.Method_SD = ...
               ['The method used to produce the density shock decompositions. This will depend on the model and estimation ',...
               'technique. See the section "Bootstrapping" in the DAG documentation for details on the ',...
               'different bootstrap options. For bayesian models it is only possible to choose "Posterior". ',...
               'The "Identification Draws" option may be available for both types of models, if you are ',...
               'dealing with an under-identified model, and the draws have been done at the identification stage ',...
               '(you need to do more than 100 draws to be able to use this option).'];                
       end       
       
        function obj = New_Draws_Share(obj)
           obj.helpStruct.New_Draws_Share = ...
               ['Use this option to set the number of redrawn parameters when out of initial parameter draws. ',...
               'The number of new draws are then equal to this input times the number of selected parameter draws.'];        
        end
        
        function obj = Normalization_IRFs(obj)
           obj.helpStruct.Normalization_IRFs = ...
               'Choose the value to normalize the IRFs to. Must be a number e.g. 100.';        
        end           
        
        function obj = Normalize_IRFs(obj)
           obj.helpStruct.Normalize_IRFs = ...
               ['Select to normalize all impulse response functions. This option will scale the value linearly to ',...
               'the desired level.'];        
        end 
        
        function obj = Normalize_IRFs_Period(obj)
           obj.helpStruct.Normalize_IRFs_Period = ...
               'Choose the period the normalization should use as a benchmark.';        
        end         
        
        function obj = Number_of_Lags(obj)
           obj.helpStruct.Number_of_Lags = ...
               ['When covariance or correlation are chosen it is possible to ask for the ',...
               'autocorrelation/-covariance matrix up to the selected number. The autocorrelation/-covariance ',...
               'matrix at each selected lag is then displayed in its own spreadsheet.'];        
        end        
        
       function obj = Number_of_Simulations(obj)
           obj.helpStruct.Number_of_Simulations = ...
               'Sets the number of residual simulations per parameter draw.';        
       end       
       
        function obj = Number_of_Steps(obj)
           obj.helpStruct.Number_of_Steps = ...
               ['Sets the number of steps into the future you want to forecast. Must be given ',...
               'as an integer.'];        
        end
        
        function obj = Output(obj)
            obj.helpStruct.Output = ...
                'Choose which output to return. Either mean, covariance (matrix) or correlation (matrix).';
        end
        
        function obj = Output_FEVD(obj)
            obj.helpStruct.Output_FEVD = ...
                'Choose between "Closest to Median" (model) or "Median". See the "Method" option for more.';
        end           
        
        function obj = Optimizer(obj)
            obj.helpStruct.Optimizer = ...
                ['Select the MATLAB optimizer routine for mimimizing the maximum likelihood function. ',...
                 'fmincon: Find minimum of constrained nonlinear multivariable function. ',...
                 'fminunc: Find minimum of unconstrained multivariable function. ',...
                 'fminsearch: Find minimum of unconstrained multivariable function using derivative-free method.'];
        end 
        
        function obj = Packaging(obj)
            obj.helpStruct.Packaging = ...
                ['Click on the button to be able to group different shocks when doing the decomposition. ',...
                'A new window will pop up.'];
        end        
        
        function obj = Parameter_Draws(obj)
            obj.helpStruct.Parameter_Draws = ...
                'The number of parameter draws using the method selected by the "Density method" option.';
        end
        
        function obj = Parameter_Draws_MM(obj)
            obj.helpStruct.Parameter_Draws_MM = ...
                ['The number of parameter draws to use to simulate the model when Type is set to simulated. ',...
                'For each parameter draw, you can set the number of residual simulations by the draws option. ',...
                'When Type is set to theoretical the moments are calculated for each parameter draw.'];
        end        
        
        function obj = Percentiles(obj)
            obj.helpStruct.Percentiles = ...
                ['Sets the desired percentiles of the density forecast. Either a number between 0 and 1, ',...
                'or a vector of numbers between 0 and 1. E.g. 0.0 (only median) or [0.3,0.5,0.7,0.9]'];
        end
        
        function obj = Percentiles_MM(obj)
            obj.helpStruct.Percentiles_MM = ...
                ['The wanted error bands of the calculated moments. Either a number between 0 and 1, or a ',...
                'vector of numbers between 0 and 1. E.g. 0 (only median) or [0.3,0.5,0.7,0.9]'];
        end  
        
        function obj = Periods(obj)
            obj.helpStruct.Periods = ...
                'The number of periods to simulate the model. Only an option when "Type" is set to simulated.';
        end  
        
        function obj = Periods_IRFs(obj)
            obj.helpStruct.Periods_IRFs = ...
                'The number of steps in the impulse response function.';
        end         
        
        function obj = PIT(obj)
            obj.helpStruct.PIT = ...
                ['"Probability integral transform". Evaluate the density forecast by how the actual data ',...
                'falls into the percentiles with bin length 0.1. If selected, a graph will be be produced. ',...
                'See section on "PIT" in the documentation for more details on this option. The "All" periods ',...
                'options should be selected to do PIT analysis correctly.'];
        end
        
        function obj = PIT_End_Date(obj)
            obj.helpStruct.PIT_End_Date = ...
                ['End date of the PIT evaluation. This date cannot be before the start date or after the end ',...
                'date of the recursive forecast.'];
        end         
        
        function obj = PIT_Start_Date(obj)
            obj.helpStruct.PIT_Start_Date = ...
                ['Start date of the PIT evaluation. This date cannot be before the start date or after the end ',...
                'date of the recursive forecast.'];
        end        
         
        function obj = Quantile(obj)
            obj.helpStruct.Quantile = ...
                ['Sets the quantile to estimate when doing quantile regression. A scalar double between 0 and 1 or a vector of ',...
                 'double values between 0 and 1. 0.5 will be the median.'];
        end        
        
        function obj = Recursive_Estimation(obj)
                obj.helpStruct.Recursive_Estimation = ...
                    ['A binary input deciding whether or not the estimation will be done recursively. ',...
                    'Tick on to estimate recursively.'];            
        end
        
        function obj = Recursive_Estimation_Start_Date(obj)
            obj.helpStruct.Recursive_Estimation_Start_Date = ...
                ['Start date of the recursive estimation. If no input is given, the default (which is to start ',...
                 'when the degrees of freedom allow it to start) will be used. '];
        end
        
        function obj = SAR(obj)
            obj.helpStruct.SAR = ...
                ['Select to include seasonal autoregressive terms. For more information and equations on how this is ',...
                 'implemented, please see the section on "Seasonal ARMA terms" in the DAG documentation.'];
        end
        
        function obj = Select_End_Horizon(obj)
            obj.helpStruct.Select_End_Horizon = ...
                ['The end period of interest. As an integer or "inf". inf will mean the FEVD of the cumulative ',...
                'sum over the infinite horizon.'];
        end
        
        function obj = Select_Start_Horizon(obj)
            obj.helpStruct.Select_Start_Horizon = ...
                'The start period of interest. As an integer.';
        end  
        
        function obj = Select_Variable(obj)
            obj.helpStruct.Select_Variable = ...
                ['Select the variable to choose the desired lag length for. ',...
                 'when the degrees of freedom allow it to start) will be used. '];
        end
        
        function obj = Set_Domains(obj)
            obj.helpStruct.Set_Domains = ...
                ['Click this button to set the upper and lower limit of the domain of the estimated density ',...
                'at each forecasting period of a given variable. Please make sure that the domain is wide ',...
                'enough to secure that the CDF of the density at each recursive forecast sum to 1. An error ',...
                'will be provided if this is not the case. If you want to combine density forecast from ',...
                'different models, you should use this option to speed up the calculation of the combined ',...
                'density forecast.'];
        end
        
        function obj = Sign(obj)
            obj.helpStruct.Sign = ...
                'The sign of the initial shock';
        end        
        
        function obj = Significance_Level_ARIMA(obj)
            obj.helpStruct.Significance_Level_ARIMA = ...
                ['Sets the significance level used for the Augmented Dickey-Fuller test. ',...
                'Only used when Integration field is empty. Must between 0 and 1.'];                          
        end
        
        function obj = SMA(obj)
            obj.helpStruct.SMA = ...
                ['Select to include seasonal moving average terms. For more information and equations on how this is ',...
                 'implemented, please see the section on "Seasonal ARMA terms" in the DAG documentation.'];
        end
        
        function obj = Stability_Test(obj)
            obj.helpStruct.Stability_Test = ...
                ['Tick this radio button to discard all parameter draws that lead to a non-stationary model. ',...
                'Only an option for density forecast.'];
        end

        function obj = Stability_Test_FEVD(obj)
            obj.helpStruct.Stability_Test_FEVD = ...
                ['Tick this radio button to discard all parameter draws that lead to a non-stationary model. ',...
                'Only an option for density FEVD.'];
        end         
        
        function obj = Stability_Test_IRFs(obj)
            obj.helpStruct.Stability_Test_IRFs = ...
                ['Tick this radio button to discard all parameter draws that lead to a non-stationary model. ',...
                'Only an option for density IRFs.'];
        end 
        
        function obj = Stability_Test_SD(obj)
            obj.helpStruct.Stability_Test_SD = ...
                ['Tick this radio button to discard all parameter draws that lead to a non-stationary model. ',...
                'Only an option for density shock decomposition.'];
        end         
        
        function obj = Start_of_Forecast(obj)
            obj.helpStruct.Start_of_Forecast = ...
                ['Start date of the forecast. If the option "Forecast evaluation" is set to None, this will give a one ',...
                'time forecast from this date. Default is the end of the estimation sample plus one. When the Forecast ',...
                'evaluation is set to something else the "Start date" option will be the start date of the recursive in ',...
                'sample forecast evaluation. If recursive estimation is done it will instead set the recursive out of ',...
                'sample forecast start date.'];
        end        
        
        function obj = Time_Trend(obj)
            obj.helpStruct.Time_Trend = ...
                ['A binary input deciding whether or not to include a time trend in the ',...
                 'estimation. The time trend is an explanatory variable monotonically increasing by one unit ',...
                 'every period. Makes sense to include if the time series becomes stationary by detrending. ',...
                 'Tick on to include the time trend variable.'];
        end
        
        function obj = Type(obj)
            obj.helpStruct.Type = ...
                ['Simulated or theoretical. If simulated is chosen the model is simulated given the other ',...
                'chosen options, and the moments are calculated based on those simulations, otherwise the ',...
                'model moments are based on calculations, see the section "Theoretical moments" in the DAG ',...
                'for how these are calculated.'];
        end        
        
        function obj = Window_Size(obj)
            obj.helpStruct.Window_Size = ...
                ['Sets the number of observations to use for each recursive estimation. Given as a scalar double. ',...
                'If no imput is given, the window will have a fixed starting point and include another observation ',...
                'for every estimation.'];
        end
        
    end
    

    
    
end
